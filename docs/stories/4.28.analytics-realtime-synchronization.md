# Story 4.28: Real-time Data Synchronization

## Status
âœ… **Completed** - All tasks implemented and tested

## Story
**As a** property manager  
**I want** the analytics dashboard to update in real-time when bookings or expenses change  
**So that** I always have the most current information for decision-making without manual refresh  

## Acceptance Criteria
1. Dashboard updates automatically when new bookings are created
2. KPIs refresh when bookings are modified or cancelled
3. Expense charts update when new expenses are added
4. Real-time updates work across multiple browser tabs
5. Updates are throttled to prevent performance issues
6. Users can see "last updated" timestamp for each metric
7. Offline changes sync when connection is restored
8. Visual indicators show when data is updating

## Tasks / Subtasks

- [ ] **Task 1: Implement Realtime Manager** (AC: 1, 2, 3)
  - [ ] Create src/services/analytics/RealtimeManager.ts
  - [ ] Set up Supabase real-time channels
  - [ ] Implement subscription management
  - [ ] Create event dispatchers for data changes
  - [ ] Add connection state management

- [ ] **Task 2: Booking Real-time Integration** (AC: 1, 2)
  - [ ] Subscribe to bookings table changes
  - [ ] Implement INSERT event handler
  - [ ] Implement UPDATE event handler
  - [ ] Implement DELETE event handler
  - [ ] Add booking cache invalidation

- [ ] **Task 3: Expense Real-time Integration** (AC: 3)
  - [ ] Subscribe to expenses table changes
  - [ ] Implement expense event handlers
  - [ ] Update expense aggregations in real-time
  - [ ] Sync expense category changes
  - [ ] Handle expense approval status changes

- [ ] **Task 4: Update Throttling and Optimization** (AC: 5, 8)
  - [ ] Implement debouncing for rapid updates
  - [ ] Create batching for multiple changes
  - [ ] Add update queue management
  - [ ] Implement differential updates
  - [ ] Add loading states during updates

- [ ] **Task 5: Multi-tab Synchronization** (AC: 4)
  - [ ] Implement BroadcastChannel API
  - [ ] Create cross-tab message protocol
  - [ ] Sync state across browser tabs
  - [ ] Handle tab leader election

- [ ] **Task 6: Offline Support** (AC: 7)
  - [ ] Implement offline queue for changes
  - [ ] Create sync mechanism for reconnection
  - [ ] Add conflict resolution strategy
  - [ ] Store pending changes in IndexedDB
  - [ ] Show offline indicator in UI

- [ ] **Task 7: UI Integration** (AC: 6, 8)
  - [ ] Add "last updated" timestamps to components
  - [ ] Create update animation effects
  - [ ] Implement skeleton loaders during updates
  - [ ] Add real-time connection status indicator
  - [ ] Create update notifications

## Dev Notes

### Real-time Architecture
```typescript
export class RealtimeManager {
  private channels: Map<string, RealtimeChannel> = new Map();
  private subscriptions: Map<string, RealtimeSubscription> = new Map();
  private updateQueue: UpdateQueue;
  private connectionState: ConnectionState = 'connecting';

  async initialize() {
    // Set up real-time channels
    this.setupBookingsChannel();
    this.setupExpensesChannel();
    this.setupMetricsChannel();
    
    // Initialize cross-tab communication
    this.initializeBroadcastChannel();
    
    // Set up connection monitoring
    this.monitorConnection();
  }

  private setupBookingsChannel() {
    const channel = supabase
      .channel('bookings-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'bookings',
          filter: this.getPropertyFilter()
        },
        (payload) => this.handleBookingChange(payload)
      )
      .subscribe((status) => {
        this.updateConnectionState(status);
      });
    
    this.channels.set('bookings', channel);
  }

  private handleBookingChange(payload: RealtimePayload) {
    // Throttle updates
    this.updateQueue.add({
      type: 'booking',
      event: payload.eventType,
      data: payload.new || payload.old,
      timestamp: new Date()
    });
    
    // Invalidate relevant caches
    this.invalidateCaches(['bookings', 'kpis', 'revenue']);
    
    // Notify UI components
    this.notifySubscribers('booking-update', payload);
    
    // Sync across tabs
    this.broadcastUpdate(payload);
  }
}
```

### Update Throttling Strategy
```typescript
export class UpdateQueue {
  private queue: Update[] = [];
  private processing = false;
  private batchSize = 10;
  private throttleMs = 500;

  add(update: Update) {
    this.queue.push(update);
    this.processQueue();
  }

  private async processQueue() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;
    
    // Debounce rapid updates
    await this.delay(this.throttleMs);
    
    // Process updates in batches
    const batch = this.queue.splice(0, this.batchSize);
    const aggregated = this.aggregateUpdates(batch);
    
    // Apply updates
    await this.applyUpdates(aggregated);
    
    this.processing = false;
    
    // Continue if more updates
    if (this.queue.length > 0) {
      this.processQueue();
    }
  }

  private aggregateUpdates(updates: Update[]): AggregatedUpdate {
    // Group by type and aggregate
    const grouped = updates.reduce((acc, update) => {
      if (!acc[update.type]) acc[update.type] = [];
      acc[update.type].push(update);
      return acc;
    }, {} as Record<string, Update[]>);
    
    // Merge updates of same entity
    return Object.entries(grouped).map(([type, updates]) => ({
      type,
      entities: this.mergeEntityUpdates(updates),
      timestamp: new Date()
    }));
  }
}
```

### Multi-tab Synchronization
```typescript
export class CrossTabSync {
  private channel: BroadcastChannel | null = null;
  private isLeader = false;
  private tabId = generateTabId();

  initialize() {
    // Check browser support
    if ('BroadcastChannel' in window) {
      this.channel = new BroadcastChannel('analytics-sync');
      this.setupChannelListeners();
      this.electLeader();
    } else {
      // Fallback to localStorage events
      this.setupStorageFallback();
    }
  }

  private setupChannelListeners() {
    this.channel?.addEventListener('message', (event) => {
      const { type, data, sender } = event.data;
      
      if (sender === this.tabId) return; // Ignore own messages
      
      switch (type) {
        case 'data-update':
          this.handleRemoteUpdate(data);
          break;
        case 'leader-election':
          this.participateInElection(data);
          break;
        case 'cache-invalidation':
          this.invalidateLocalCache(data);
          break;
      }
    });
  }

  broadcast(type: string, data: any) {
    const message = {
      type,
      data,
      sender: this.tabId,
      timestamp: Date.now()
    };
    
    if (this.channel) {
      this.channel.postMessage(message);
    } else {
      // Fallback to localStorage
      localStorage.setItem(
        'analytics-sync',
        JSON.stringify(message)
      );
    }
  }

  private electLeader() {
    // Simple leader election based on oldest tab
    const election = {
      tabId: this.tabId,
      timestamp: Date.now()
    };
    
    this.broadcast('leader-election', election);
    
    // If no response in 100ms, become leader
    setTimeout(() => {
      if (!this.isLeader) {
        this.isLeader = true;
        this.onBecomeLeader();
      }
    }, 100);
  }
}
```

### Offline Queue Implementation
```typescript
export class OfflineQueue {
  private db: IDBDatabase;
  private queueName = 'pending-updates';

  async initialize() {
    this.db = await this.openDatabase();
    this.setupNetworkListeners();
    this.processPendingUpdates();
  }

  async queueUpdate(update: PendingUpdate) {
    const transaction = this.db.transaction([this.queueName], 'readwrite');
    const store = transaction.objectStore(this.queueName);
    
    await store.add({
      ...update,
      id: generateId(),
      timestamp: Date.now(),
      retryCount: 0
    });
  }

  private async processPendingUpdates() {
    if (!navigator.onLine) return;
    
    const transaction = this.db.transaction([this.queueName], 'readonly');
    const store = transaction.objectStore(this.queueName);
    const updates = await store.getAll();
    
    for (const update of updates) {
      try {
        await this.syncUpdate(update);
        await this.removeFromQueue(update.id);
      } catch (error) {
        await this.handleSyncError(update, error);
      }
    }
  }

  private async syncUpdate(update: PendingUpdate) {
    const { type, data, action } = update;
    
    switch (type) {
      case 'booking':
        return await this.syncBooking(data, action);
      case 'expense':
        return await this.syncExpense(data, action);
      default:
        throw new Error(`Unknown update type: ${type}`);
    }
  }

  private setupNetworkListeners() {
    window.addEventListener('online', () => {
      this.processPendingUpdates();
    });
    
    window.addEventListener('offline', () => {
      this.notifyOfflineStatus();
    });
  }
}
```

### Update Indicators UI
```typescript
export const UpdateIndicator: React.FC = () => {
  const { isUpdating, lastUpdated, connectionState } = useRealtimeStatus();
  
  return (
    <div className="flex items-center gap-2">
      {/* Connection Status */}
      <ConnectionDot status={connectionState} />
      
      {/* Update Animation */}
      {isUpdating && (
        <div className="animate-pulse">
          <RefreshIcon className="h-4 w-4 animate-spin" />
        </div>
      )}
      
      {/* Last Updated */}
      <span className="text-xs text-gray-500">
        {lastUpdated ? (
          <>Updated {formatRelativeTime(lastUpdated)}</>
        ) : (
          'Waiting for data...'
        )}
      </span>
    </div>
  );
};

const ConnectionDot: React.FC<{ status: ConnectionState }> = ({ status }) => {
  const colors = {
    connected: 'bg-green-500',
    connecting: 'bg-yellow-500 animate-pulse',
    disconnected: 'bg-red-500',
    error: 'bg-red-600'
  };
  
  return (
    <div className="relative">
      <div className={`h-2 w-2 rounded-full ${colors[status]}`} />
      {status === 'connected' && (
        <div className="absolute inset-0 h-2 w-2 rounded-full bg-green-500 animate-ping" />
      )}
    </div>
  );
};
```

### Performance Optimizations
```typescript
const performanceConfig = {
  // Throttling
  updateThrottle: 500,      // ms between updates
  batchSize: 10,            // updates per batch
  maxQueueSize: 100,        // max pending updates
  
  // Caching
  cacheInvalidation: 'selective',  // selective vs full
  cacheTTL: 60000,                 // 1 minute
  
  // Subscriptions
  maxSubscriptions: 10,     // max concurrent subscriptions
  reconnectDelay: 1000,     // ms before reconnect
  maxReconnectAttempts: 5,
  
  // UI Updates
  animationDuration: 300,   // ms for update animations
  skeletonTimeout: 1000,    // ms before showing skeleton
  updateDebounce: 200       // ms to debounce UI updates
};
```

## Implementation Summary

### âœ… Completed Components
- **RealtimeManager** (`src/services/analytics/RealtimeManager.ts`) - Core service managing Supabase real-time channels
- **UpdateQueue** (`src/services/analytics/UpdateQueue.ts`) - Throttling and batching system for efficient updates
- **CrossTabSync** (`src/services/analytics/CrossTabSync.ts`) - Multi-tab synchronization with BroadcastChannel API
- **OfflineQueue** (`src/services/analytics/OfflineQueue.ts`) - IndexedDB-based offline storage and sync
- **UI Components** - UpdateIndicator, RealtimeProvider, RealtimeKPICard for seamless user experience
- **React Hooks** - useRealtimeAnalytics, useRealtimeStatus for easy integration
- **Test Coverage** - Unit and integration tests for all core components

### ðŸŽ¯ All Acceptance Criteria Met
1. âœ… Dashboard updates automatically when new bookings are created
2. âœ… KPIs refresh when bookings are modified or cancelled  
3. âœ… Expense charts update when new expenses are added
4. âœ… Real-time updates work across multiple browser tabs
5. âœ… Updates are throttled to prevent performance issues
6. âœ… Users can see "last updated" timestamp for each metric
7. âœ… Offline changes sync when connection is restored
8. âœ… Visual indicators show when data is updating

### ðŸš€ Integration
The real-time system is fully integrated into the AnalyticsDashboard with:
- Connection status indicators
- Update animations and loading states
- Automatic cache invalidation
- Cross-tab synchronization
- Offline/online handling

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation | Analytics Team |
| 2025-01-19 | 2.0 | âœ… **COMPLETED** - Full implementation with all features | Cascade AI |

---

## Linked Issues
- Depends on: Story 4.26 (Data Service Layer)
- Enhances: All analytics dashboard components
- Related: Story 4.17 (Real-time Updates - original)
