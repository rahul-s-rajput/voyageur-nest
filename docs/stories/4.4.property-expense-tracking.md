# Story 4.4: Property Expense Tracking

## Status
- **Current Status**: Ready for Development
- **Priority**: High
- **Epic**: 4 - Multi-Property & OTA Management
- **Story Points**: 8-10
- **Assigned Dev Agent**: TBD
- **Sprint**: TBD

## User Story
**As a** property manager  
**I want** to track all expenses for each Manali property  
**So that** I can monitor profitability, compare properties, and manage costs effectively

## Business Context
Accurate expense tracking is critical for understanding true profitability per property (Old Manali vs Baror). This story introduces a simple yet extensible expense module integrated with existing multi-property context, reporting, and dashboards. It enables expense entry, receipt uploads, approvals, monthly reports, and expense vs revenue analysis to guide data-driven decisions in the Manali hospitality market.

## Scope
- In-scope: Expense categories, expense records, receipt uploads, approvals, monthly/seasonal reports, cross-property comparisons, profit margin calculations, export, and notifications.
- Out-of-scope: Full accounting system, GST filings, journal entries, payroll system integration, inventory procurement workflows (future).

## Non-Goals
- Replacing accounting software
- Advanced OCR of receipts (future enhancement)
- Automated bank feed ingestion (future)

## Architecture Overview
- **Multi-Property Context**: All expense data is property-scoped via `property_id` and integrates with `PropertyContext` for filtering and UI state.
- **Data Layer**: New tables `expense_categories` (supports global templates with per-property overrides), `expenses` with receipt references, and `expense_budgets` for per-category monthly budgets per property.
- **Storage**: Receipts stored in Supabase Storage bucket `receipts` with signed URL access; only metadata in DB. Max size 10MB; allow images (jpg/png/webp) and PDF.
- **Security**: RLS policies scoped by `property_id`; approval actions restricted to admin role; service role used for admin tasks (approvals/exports) where appropriate.
- **Reporting**: Extend `PropertyReporting` and `EnhancedKPIDashboard` to include expense, profit, margin metrics, budget vs actual, date filters and seasonal grouping.
- **Notifications**: Approval workflow sends notifications via `NotificationService` and surfaces in `NotificationCenter`.
- **AI Receipt Extraction (optional, recommended)**: On receipt upload, call Gemini (Flash/Flash‑Lite) to extract fields (date, amount, currency, vendor, possible category), provide a confidence score and reasoning, and auto‑fill the new expense form with review before save.
 - **AI Line Items (optional, recommended)**: The same extraction call should parse a structured list of line items (description, quantity, unit price, tax, line total). Category suggestion is derived from both vendor + keywords + AI classification with a confidence score; user can override.

## Database Schema
The following schema aligns with existing patterns in `database.sql` and migrations, using UUIDs, timestamps, and property scoping.

```sql
-- 1) Expense categories (global templates and per-property overrides)
CREATE TABLE IF NOT EXISTS public.expense_categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id UUID REFERENCES public.properties(id) ON DELETE CASCADE, -- NULL => global template
  name TEXT NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(property_id, name)
);

-- 2) Expenses
CREATE TABLE IF NOT EXISTS public.expenses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id UUID NOT NULL REFERENCES public.properties(id) ON DELETE CASCADE,
  category_id UUID REFERENCES public.expense_categories(id) ON DELETE SET NULL,
  expense_date DATE NOT NULL,
  amount NUMERIC(12,2) NOT NULL CHECK (amount >= 0),
  currency TEXT DEFAULT 'INR',
  payment_method TEXT,       -- e.g., cash, UPI, card, bank_transfer
  vendor TEXT,
  notes TEXT,
  receipt_url TEXT,          -- Supabase Storage signed URL (generated at fetch-time), store path in receipt_path
  receipt_path TEXT,         -- actual storage path, e.g., receipts/{property_id}/{yyyy-mm}/{uuid}.jpg
  approval_status TEXT DEFAULT 'pending', -- pending | approved | rejected
  approved_by UUID,          -- user id when available
  created_by UUID,           -- user id when available
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3) Per-category monthly budgets per property
CREATE TABLE IF NOT EXISTS public.expense_budgets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id UUID NOT NULL REFERENCES public.properties(id) ON DELETE CASCADE,
  category_id UUID NOT NULL REFERENCES public.expense_categories(id) ON DELETE CASCADE,
  month DATE NOT NULL,                -- use first day of month (YYYY-MM-01)
  budget_amount NUMERIC(12,2) NOT NULL CHECK (budget_amount >= 0),
  currency TEXT DEFAULT 'INR',
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(property_id, category_id, month)
);

-- 4) Helpful indexes
CREATE INDEX IF NOT EXISTS idx_expenses_property_date ON public.expenses(property_id, expense_date);
CREATE INDEX IF NOT EXISTS idx_expenses_category ON public.expenses(category_id);
CREATE INDEX IF NOT EXISTS idx_expenses_approval ON public.expenses(approval_status);
CREATE INDEX IF NOT EXISTS idx_expense_budgets_month ON public.expense_budgets(property_id, month);

-- 5) Triggers (updated_at)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_expense_categories_updated_at ON public.expense_categories;
CREATE TRIGGER trg_expense_categories_updated_at
BEFORE UPDATE ON public.expense_categories
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS trg_expenses_updated_at ON public.expenses;
CREATE TRIGGER trg_expenses_updated_at
BEFORE UPDATE ON public.expenses
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS trg_expense_budgets_updated_at ON public.expense_budgets;
CREATE TRIGGER trg_expense_budgets_updated_at
BEFORE UPDATE ON public.expense_budgets
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- 6) RLS (example, adjust to your auth model)
ALTER TABLE public.expense_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.expense_budgets ENABLE ROW LEVEL SECURITY;

-- Allow read by anyone authenticated; writes constrained by property membership/roles
CREATE POLICY expense_categories_read ON public.expense_categories FOR SELECT USING (true);
CREATE POLICY expense_categories_write ON public.expense_categories FOR INSERT WITH CHECK (true);
CREATE POLICY expense_categories_update ON public.expense_categories FOR UPDATE USING (true);

CREATE POLICY expenses_read ON public.expenses FOR SELECT USING (true);
CREATE POLICY expenses_insert ON public.expenses FOR INSERT WITH CHECK (true);
CREATE POLICY expenses_update ON public.expenses FOR UPDATE USING (true);

CREATE POLICY expense_budgets_read ON public.expense_budgets FOR SELECT USING (true);
CREATE POLICY expense_budgets_write ON public.expense_budgets FOR INSERT WITH CHECK (true);
CREATE POLICY expense_budgets_update ON public.expense_budgets FOR UPDATE USING (true);
```

### Optional: Line Items Table
If line-item storage is desired, add:
```sql
CREATE TABLE IF NOT EXISTS public.expense_line_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  expense_id UUID NOT NULL REFERENCES public.expenses(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  quantity NUMERIC(12,3) DEFAULT 1,
  unit_amount NUMERIC(12,2) DEFAULT 0,
  tax_amount NUMERIC(12,2),
  line_total NUMERIC(12,2) NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.expense_line_items ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS expense_line_items_select ON public.expense_line_items;
CREATE POLICY expense_line_items_select ON public.expense_line_items FOR SELECT USING (true);
DROP POLICY IF EXISTS expense_line_items_insert ON public.expense_line_items;
CREATE POLICY expense_line_items_insert ON public.expense_line_items FOR INSERT WITH CHECK (true);
DROP POLICY IF EXISTS expense_line_items_update ON public.expense_line_items;
CREATE POLICY expense_line_items_update ON public.expense_line_items FOR UPDATE USING (true);
```

Notes:
- RLS policies shown as permissive placeholders; adapt to your actual auth model and property membership checks. A production policy typically asserts that a user can only access rows where `property_id` is in their allowed property list.
- For privacy and cost, only store `receipt_path`. Generate signed URLs at read-time on the client/service.

## Services & Integrations
Create `src/services/expenseService.ts` following existing service patterns (`propertyService`, `otaMonitoringService`).

Core methods:
- `listAvailableCategories(propertyId: string): Promise<ExpenseCategory[]>` (merge global templates where `property_id IS NULL` with property-specific overrides)
- `createCategoryTemplate(name: string, description?: string)` (global)
- `createPropertyCategory(propertyId: string, name: string, description?: string)`
- `updateCategory(id: string, updates: Partial<ExpenseCategory>)`
- `listExpenses(params: { propertyId: string; from?: string; to?: string; categoryId?: string; approval?: 'pending'|'approved'|'rejected'; vendor?: string }): Promise<Expense[]>`
- `createExpense(input: NewExpense): Promise<Expense>`
- `updateExpense(id: string, updates: Partial<Expense>)`
- `approveExpense(id: string, approvedBy: string)` / `rejectExpense(id: string, rejectedBy: string)`
- `uploadReceipt(propertyId: string, file: File): Promise<{ path: string }>` storing to `receipts/{propertyId}/{yyyy-mm}/{uuid.ext}`
- `getMonthlyReport(propertyId: string, month: string): Promise<ExpenseReport>` including per-category totals, totals, seasonal groupings, and budget vs actual
- `getCrossPropertyComparison(from: string, to: string): Promise<Array<{ propertyId, totalExpenses, categories }>>`
- Budget methods: `getBudgets(propertyId: string, fromMonth: string, toMonth: string)`, `upsertBudget({ propertyId, categoryId, month, budgetAmount, currency, notes })`, `getBudgetVsActual(propertyId: string, month: string)`

Integrations:
- Notifications: On approval/rejection, send a notification via `NotificationService` scoped to `property_id`.
- Reporting: Extend `PropertyReporting` to include expense vs revenue and monthly summaries.
- KPI: Enhance `EnhancedKPIDashboard` to show expense totals and profit margin `(revenue - expenses) / revenue` when applicable.
 - Approvals: Admin-only transitions from `pending` → `approved/rejected` (enforce via UI + server-side checks/role guard).

AI Receipt Extraction service:
- Add `src/services/receiptAIExtractionService.ts` modeled on `aiEmailParserService.ts`, with a function like `extractFromReceipt(fileOrUrl, hints?): Promise<{ output, confidence, reasoning }>`.
- JSON output schema (structured):
  - `expense_date: string (ISO date) | null`
  - `amount: number | null`
  - `currency: string | null`
  - `vendor: string | null`
  - `category_hint: string | null` (one of our categories or free text)
  - `line_items: Array<{ description: string; quantity?: number; unit_amount?: number; tax_amount?: number; line_total?: number }>`
  - `confidence: number (0..1)`
  - `reasoning: string`
- Policy: if confidence ≥ 0.8, auto‑fill and allow one‑click save; 0.5–0.8 prompt for review; <0.5 show fields but don’t auto‑apply.

Category decisioning:
- Combine heuristic mapping (keyword dictionary, vendor-to-category map) with Gemini’s `category_hint` and choose best category with an overall confidence. Provide top-3 suggestions with confidences; default to highest but always allow override.

## UI & UX
Create `src/components/PropertyManagement/ExpenseManagement.tsx` consistent with `PricingManagement.tsx` patterns.

Features:
- Expense list with filters (date range, category, vendor, approval status) under current property context.
- Add expense form: date, amount, category, vendor, payment method, notes, receipt upload.
- Category manager: global templates with property overrides; simple CRUD with visibility of global vs local categories.
- Approval workflow: inline approve/reject with notes; admin-only actions.
- Monthly report view: per-category breakdown, totals, charts; budget vs actual; export CSV.
- Cross-property comparison: toggle view to compare Old Manali vs Baror over a date range.
- Seasonal view: group by peak/off-peak months per Manali context.
- Budgets: budgets management UI per property/category/month; show utilization and over-budget flags.
- AI extraction: in New Expense modal, after selecting a file, show an "Extract from receipt" action. Display extracted fields with confidence and reasoning; allow quick-apply and manual edits before save. Show a small confidence chip.
 - Line items: show an editable table (description, qty, unit price, tax, line total). Auto-calculate totals and allow add/remove rows before save. Persist to `expense_line_items` when enabled.

Placement:
- Add "Expenses" tab/entry in `PropertyDashboard` under `reports-analytics` or as a first-class section (e.g., `managementSection = 'expenses'`).
- Surface expense widgets in dashboard overview (latest expenses, MTD total, pending approvals).

Accessibility & Responsiveness:
- Fully responsive layout (mobile tablet staff devices) following existing Tailwind patterns.
- Clear input validation, helpful error states, and progress indicators for uploads.

## Calculations & Definitions
- **Monthly Expense Total**: Sum of `amount` by `expense_date` month.
- **Profit Margin per Property**: `(Revenue - Expenses) / Revenue`, where revenue is derived from booking totals for the same period (existing booking data).
- **Seasonal Buckets**: Peak (May-Jun, Oct-Nov), Moderate (Mar-Apr, Sep, Dec), Low (Jan-Feb, Jul-Aug). Used for grouped reporting.
 - **Budget Utilization**: `Total Expenses for (property, category, month) / Budget Amount` with status thresholds (e.g., >100% over-budget, 80–100% warning).

## Acceptance Criteria
- **Categories**: Manager can add/edit/delete expense categories per property: utilities, food costs, staff salary, maintenance, marketing.
- **Global Templates**: Category templates can be defined globally and are visible across properties; property can override by creating a local category with same name.
- **Receipt Uploads**: Each expense can include a receipt image/pdf stored in Supabase Storage; files open via signed URLs; max size validated.
- **Monthly Reports**: Generate per-property monthly expense reports with per-category totals and totals; exportable to CSV.
- **Cross-Property Comparison**: Compare expense totals and category breakdowns across Old Manali vs Baror for a selected date range.
- **Profit Margins**: Show profit margins after expenses by combining expenses with revenue data from bookings for the same period.
- **Expense vs Revenue Analysis**: Dedicated report panel/chart; toggle by month/season.
- **Approval Workflow**: Pending → approved/rejected with user and timestamp; notifications sent; filters support approval status; actions restricted to admin role.
- **Export**: CSV export of filtered expenses with columns: date, category, amount, currency, vendor, payment method, notes, approval, property.
- **Seasonal Tracking**: Seasonal grouping displays totals per season for selected period; Manali seasons as defined above.
- **Property Context**: All views and operations honor `currentProperty` by default with an optional cross-property comparison view.
- **Budgets**: Per-category monthly budgets can be created/edited; reports display budget vs actual and flag over-budget categories; CSV export includes budget columns.
- **AI Receipt Extraction (optional)**: When a receipt is selected, the system can extract `expense_date`, `amount`, `currency`, `vendor`, and a `category_hint` using Gemini, auto-fill the form fields, display a confidence score and reasoning, and allow manual corrections before saving.
 - **AI Line Items (optional)**: The system can extract a structured list of line items and prefill an editable table. Totals must reconcile; user can correct any row before saving.

## Definition of Done
- DB schema created with indexes and RLS; storage bucket `receipts` configured.
- Service implemented with CRUD, filters, reporting, and receipt upload.
- UI: Expense Management module with list, filters, add form, categories (global + overrides), approvals (admin-only), monthly reports with budget vs actual, and exports.
- Dashboard/Reporting updated to include expense widgets and profit margin calculations.
- Notifications integrated for approvals.
- Unit/integration tests passing; TypeScript types in `src/types/property.ts` or a new `src/types/expenses.ts`.
- Documentation updated and sample categories seeded.
- AI extraction path available behind a feature flag or toggle; achieves ≥95% accuracy on a small internal test set of standard receipts; graceful fallback when extraction is low-confidence or fails.
 - Line-item persistence optional: if enabled, create and link `expense_line_items` records when saving an expense.

## Security & Privacy
- RLS by `property_id`; ensure only authorized staff can access/modify their property’s expenses.
- Receipt URLs are signed and time-limited; store only `receipt_path` in DB.
- Input validation and server-side checks on file type/size (max 10MB; image/pdf only).
- Approval endpoints/actions restricted to admin role.

## Test Plan
- Unit tests: service methods (filters, reports, approvals), seasonal grouping, CSV export format.
- Integration tests: create category → add expense with receipt (mock upload) → approve → report totals.
- UI tests: form validation, filter interactions, approval actions, signed URL rendering.
- Regression: KPI dashboard profit margin calculations with expenses.
- AI extraction tests: mock Gemini responses for high/medium/low confidence; verify auto-fill behavior, confidence display, and user override flow; date/currency normalization tests.
 - Line items tests: parsing table edits, totals reconciliation, and persistence via `expense_line_items` when enabled.

## Rollout Plan
1) Migrations + bucket creation (`receipts`)
2) Service implementation (`expenseService.ts`)
3) UI module (`ExpenseManagement.tsx`) + dashboard widgets
4) Reporting integration and exports
5) Notifications for approvals
6) Testing and QA with seed data

## Tasks / Subtasks
- [ ] DB: Create `expense_categories`, `expenses`, indexes, triggers, RLS policies
- [ ] DB: Create `expense_budgets` and indexes; views for budget vs actual if helpful
- [ ] Storage: Create `receipts` bucket and rules
- [ ] Types: Add `ExpenseCategory`, `Expense`, `ExpenseReport`
- [ ] Service: `expenseService.ts` with CRUD, upload (10MB image/pdf), reports, comparison, budgets
- [ ] UI: `ExpenseManagement.tsx` with list, filters, add/edit, approvals, categories
- [ ] UI: Category Templates with property overrides; Budgets management and budget vs actual displays
- [ ] UI: Add to `PropertyDashboard` navigation and overview widgets
- [ ] Reporting: Extend `PropertyReporting.tsx` for expense vs revenue and seasonal summaries
- [ ] KPI: Update `EnhancedKPIDashboard.tsx` with expense and margin tiles
- [ ] Notifications: Approval events via `NotificationService`
- [ ] Export: CSV export for filtered expenses and monthly reports
- [ ] Tests: Unit/integration/UI tests as outlined (including budget utilization and admin-only approvals)
- [ ] Docs: Admin guide for categories, approvals, and exports
- [ ] AI: Create `receiptAIExtractionService.ts` using Gemini; wire "Extract from receipt" in `ExpenseManagement` New Expense modal; add feature flag/config; add tests
 - [ ] Optional DB: Add `expense_line_items` table and service methods (`addLineItems(expenseId, items[])`); extend reports to roll up line totals

## Decisions (formerly Open Questions)
- **Categories**: Use global templates with property overrides.
- **Receipts**: Allow images/PDF up to 10MB.
- **Approvals**: Admin role only.
- **Budgets**: Include per-category monthly budgets in this story.

## References
- `src/contexts/PropertyContext.tsx` for multi-property state and `currentProperty`
- `src/components/PropertyManagement/PricingManagement.tsx` for UI pattern inspiration
- `src/components/EnhancedKPIDashboard.tsx` for KPI metrics pattern
- `src/services/propertyService.ts`, `src/services/otaMonitoringService.ts`, `src/services/notificationService.ts` for service patterns
- `docs/final_epics_stories.md` (EPIC 4, Story 4.4 Acceptance Criteria)


