# Story 5.3: Unified Supabase Client Configuration

## Status
✅ **COMPLETED** - Dual Supabase client configuration implemented

## Progress Summary
- ✅ Unified client implemented in `src/lib/supabase/index.ts` with PKCE, session persistence, auto-refresh, error handling.
- ✅ Auth integration via `src/contexts/AuthContext.tsx` (role checks, multi-tab sync, session handling).
- ✅ Environment-aware config in `src/lib/supabase/config.ts` using Vite env vars (`VITE_SUPABASE_*`).
- ✅ Performance monitoring and health checks in `src/lib/supabase/monitoring.ts`.
- ✅ Services migrated to unified client in `src/lib/supabase/services.ts`.
- ✅ Tests present under `src/lib/supabase/__tests__/` and related hooks/services.
- ✅ Env vars validated and documented for deployment.

## Story
**As a** developer  
**I want** to implement a unified Supabase client configuration that leverages RLS policies for access control  
**So that** I can maintain a simple, secure, and maintainable authentication system while ensuring proper separation between public and admin functionality  

## Acceptance Criteria

### Unified Client Configuration
1. Single Supabase client is configured with optimal settings
2. Client supports both authenticated and anonymous access patterns
3. Authentication state is managed through React context
4. RLS policies handle access control instead of client separation
5. Client configuration is environment-aware (dev/staging/prod)
6. Proper error handling for network and authentication issues
7. Automatic token refresh for authenticated sessions
8. Session persistence across browser sessions for admin users
9. PKCE flow is enabled for enhanced security
10. Client includes comprehensive logging and monitoring

### Authentication Integration
11. Client integrates seamlessly with AuthContext
12. Anonymous access works for public customer features
13. Admin authentication provides elevated access
14. Session management handles sign-in/sign-out gracefully
15. Authentication state changes are handled smoothly
16. Proper cleanup occurs on authentication state changes
17. Multiple tab synchronization works correctly
18. Authentication errors are handled user-friendly
19. Loading states are managed appropriately
20. Security best practices are implemented throughout

### Access Control & Security
21. RLS policies enforce data access control
22. Public operations work without authentication
23. Admin operations require proper authentication
24. Cross-user data access is prevented
25. Sensitive operations include proper validation
26. Security headers are configured appropriately
27. Environment variables are properly secured
28. Client initialization includes security validation
29. Error messages don't leak sensitive information
30. Audit logging tracks authentication events

### Performance & Integration
31. Client initialization is optimized for performance
32. Bundle size impact is minimized
33. Network requests are efficiently managed
34. Connection pooling works appropriately
35. Memory leaks are prevented
36. Offline scenarios are handled gracefully
37. Performance monitoring is integrated
38. Client integrates with existing codebase patterns
39. TypeScript types are properly defined
40. Migration from device tokens is seamless

## Tasks / Subtasks

- [x] **Task 1: Unified Client Setup** (AC: 1-10)
  - [x] Create `src/lib/supabase.ts` with unified client configuration
  - [x] Configure client with optimal settings for both use cases
  - [x] Implement environment-aware configuration
  - [x] Add proper TypeScript types and interfaces
  - [x] Configure authentication with PKCE and token refresh
  - [x] Set up session persistence for admin users
  - [x] Implement proper error handling and logging
  - [x] Test client initialization across environments

- [x] **Task 2: Authentication Integration** (AC: 11-20)
  - [x] Integrate client with existing AuthContext
  - [x] Update authentication flows to use unified client
  - [x] Implement session management and state handling
  - [x] Add multi-tab synchronization
  - [x] Update sign-in/sign-out functionality
  - [x] Implement proper loading states
  - [x] Test authentication state changes
  - [x] Validate error handling and user feedback

- [x] **Task 3: Access Control Integration** (AC: 21-30)
  - [x] Validate RLS policies work with unified client
  - [x] Test public operations without authentication
  - [x] Test admin operations with authentication
  - [x] Implement security validation and headers
  - [x] Add audit logging for authentication events
  - [x] Test cross-user data access prevention
  - [x] Validate sensitive operation protection
  - [x] Document security considerations

- [x] **Task 4: Performance & Migration** (AC: 31-40)
  - [x] Optimize client initialization and bundle size
  - [x] Update existing API calls to use unified client
  - [x] Migrate from device token authentication
  - [x] Implement performance monitoring
  - [x] Add offline scenario handling
  - [x] Test memory management and prevent leaks
  - [x] Validate TypeScript integration
  - [x] Create comprehensive documentation

## Dev Notes

### Unified Supabase Client Configuration
```typescript
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js'
import type { Database } from './types/database.types'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL!
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY!

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables')
}

// Unified Supabase client - handles both public and authenticated access via RLS
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    // Enable session persistence for admin users
    persistSession: true,
    // Enable automatic token refresh
    autoRefreshToken: true,
    // Enable session detection for auth callbacks
    detectSessionInUrl: true,
    // Use localStorage for session persistence
    storage: typeof window !== 'undefined' ? window.localStorage : undefined,
    // Use PKCE flow for enhanced security
    flowType: 'pkce'
  },
  realtime: {
    // Moderate realtime usage
    params: {
      eventsPerSecond: 5
    }
  },
  global: {
    headers: {
      'X-Client-Version': import.meta.env.VITE_APP_VERSION || '1.0.0'
    }
  },
  db: {
    schema: 'public'
  }
})

// API helper functions that work with RLS policies
export const api = {
  // Public operations (work without authentication due to RLS policies)
  async getMenuItems() {
    const { data, error } = await supabase
      .from('menu_items')
      .select('*')
      .eq('is_available', true)
      .is('deleted_at', null)
      .order('display_order')
    
    if (error) {
      console.error('Error fetching menu items:', error)
      throw new Error('Failed to load menu items')
    }
    
    return data
  },

  async getMenuCategories() {
    const { data, error } = await supabase
      .from('menu_categories')
      .select('*')
      .eq('is_active', true)
      .order('display_order')
    
    if (error) {
      console.error('Error fetching menu categories:', error)
      throw new Error('Failed to load menu categories')
    }
    
    return data
  },

  async getRoomTypes() {
    const { data, error } = await supabase
      .from('room_types')
      .select('*')
      .eq('is_active', true)
      .eq('is_bookable', true)
      .order('base_price')
    
    if (error) {
      console.error('Error fetching room types:', error)
      throw new Error('Failed to load room types')
    }
    
    return data
  },

  async getProperties() {
    const { data, error } = await supabase
      .from('properties')
      .select('*')
      .eq('is_active', true)
      .order('name')
    
    if (error) {
      console.error('Error fetching properties:', error)
      throw new Error('Failed to load properties')
    }
    
    return data
  },

  // Booking operations (public can create, admin can modify via RLS)
  async createBooking(bookingData: any) {
    const { data, error } = await supabase
      .from('bookings')
      .insert(bookingData)
      .select()
      .single()
    
    if (error) {
      console.error('Error creating booking:', error)
      throw new Error('Failed to create booking')
    }
    
    return data
  },

  async createGuestProfile(guestData: any) {
    const { data, error } = await supabase
      .from('guest_profiles')
      .insert(guestData)
      .select()
      .single()
    
    if (error) {
      console.error('Error creating guest profile:', error)
      throw new Error('Failed to create guest profile')
    }
    
    return data
  },

  // Admin operations (require authentication, enforced by RLS)
  async getAllBookings() {
    const { data, error } = await supabase
      .from('bookings')
      .select(`
        *,
        guest_profiles(*),
        room_types(*),
        properties(*)
      `)
      .order('created_at', { ascending: false })
    
    if (error) {
      console.error('Error fetching bookings:', error)
      throw new Error('Failed to load bookings')
    }
    
    return data
  },

  async getAllExpenses() {
    const { data, error } = await supabase
      .from('expenses')
      .select('*')
      .order('date', { ascending: false })
    
    if (error) {
      console.error('Error fetching expenses:', error)
      throw new Error('Failed to load expenses')
    }
    
    return data
  },

  async createExpense(expenseData: any) {
    const { data, error } = await supabase
      .from('expenses')
      .insert(expenseData)
      .select()
      .single()
    
    if (error) {
      console.error('Error creating expense:', error)
      throw new Error('Failed to create expense')
    }
    
    return data
  }
}

// Authentication helpers
export const auth = {
  async signIn(email: string, password: string) {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    })
    
    if (error) {
      console.error('Sign in error:', error)
      throw new Error(error.message)
    }
    
    return data
  },

  async signOut() {
    const { error } = await supabase.auth.signOut()
    
    if (error) {
      console.error('Sign out error:', error)
      throw new Error('Failed to sign out')
    }
  },

  async getCurrentUser() {
    const { data: { user }, error } = await supabase.auth.getUser()
    
    if (error) {
      console.error('Get user error:', error)
      return null
    }
    
    return user
  },

  async getSession() {
    const { data: { session }, error } = await supabase.auth.getSession()
    
    if (error) {
      console.error('Get session error:', error)
      return null
    }
    
    return session
  }
}

// Error handling wrapper for API calls
export const withErrorHandling = <T extends any[], R>(
  fn: (...args: T) => Promise<R>
) => {
  return async (...args: T): Promise<R> => {
    try {
      return await fn(...args)
    } catch (error) {
      // Log error for monitoring
      console.error('API Error:', {
        function: fn.name,
        args: args,
        error: error
      })
      
      // Re-throw with user-friendly message
      if (error instanceof Error) {
        throw error
      }
      
      throw new Error('An unexpected error occurred')
    }
  }
}

// TypeScript types for better development experience
export type SupabaseClient = typeof supabase

// Re-export commonly used types
export type { Database } from './types/database.types'
export type { User, Session, AuthError } from '@supabase/supabase-js'

// Default export for convenience
export default supabase
```

### Admin Client Configuration
```typescript
// lib/supabase/supabaseAdmin.ts
import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/database.types'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL!
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY!

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables for admin client')
}

// Admin client configuration - full authentication features
export const supabaseAdmin = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    // Enable session persistence for admin users
    persistSession: true,
    // Enable automatic token refresh
    autoRefreshToken: true,
    // Enable session detection in URL
    detectSessionInUrl: true,
    // Use localStorage for session persistence
    storage: typeof window !== 'undefined' ? window.localStorage : undefined,
    // Use PKCE flow for enhanced security
    flowType: 'pkce'
  },
  realtime: {
    // Enable realtime for admin notifications
    params: {
      eventsPerSecond: 10
    }
  },
  global: {
    headers: {
      'X-Client-Type': 'admin',
      'X-Client-Version': import.meta.env.VITE_APP_VERSION || '1.0.0'
    }
  },
  db: {
    schema: 'public'
  }
})

// Admin authentication helpers
export const adminAuth = {
  async signIn(email: string, password: string) {
    const { data, error } = await supabaseAdmin.auth.signInWithPassword({
      email,
      password
    })
    
    if (error) {
      console.error('Admin sign in error:', error)
      throw new Error(error.message)
    }
    
    // Verify admin role
    const user = data.user
    if (!user) {
      throw new Error('Authentication failed')
    }
    
    // Check if user has admin role in JWT
    const isAdmin = user.app_metadata?.is_admin || 
                   user.user_metadata?.is_admin ||
                   false
    
    if (!isAdmin) {
      await supabaseAdmin.auth.signOut()
      throw new Error('Access denied: Admin privileges required')
    }
    
    return data
  },

  async signOut() {
    const { error } = await supabaseAdmin.auth.signOut()
    
    if (error) {
      console.error('Admin sign out error:', error)
      throw new Error('Failed to sign out')
    }
  },

  async refreshSession() {
    const { data, error } = await supabaseAdmin.auth.refreshSession()
    
    if (error) {
      console.error('Session refresh error:', error)
      throw new Error('Failed to refresh session')
    }
    
    return data
  },

  async getCurrentUser() {
    const { data: { user }, error } = await supabaseAdmin.auth.getUser()
    
    if (error) {
      console.error('Get user error:', error)
      return null
    }
    
    return user
  },

  async getSession() {
    const { data: { session }, error } = await supabaseAdmin.auth.getSession()
    
    if (error) {
      console.error('Get session error:', error)
      return null
    }
    
    return session
  },

  // Check if current user is admin
  async isAdmin(): Promise<boolean> {
    const user = await this.getCurrentUser()
    
    if (!user) {
      return false
    }
    
    return user.app_metadata?.is_admin || 
           user.user_metadata?.is_admin ||
           false
  },

  // Get user role from JWT
  async getUserRole(): Promise<string> {
    const user = await this.getCurrentUser()
    
    if (!user) {
      return 'anonymous'
    }
    
    return user.app_metadata?.user_role || 
           user.user_metadata?.user_role ||
           'user'
  }
}

// Admin API helpers
export const adminApi = {
  // Booking management
  async getAllBookings() {
    const { data, error } = await supabaseAdmin
      .from('bookings')
      .select(`
        *,
        guest_profiles(*),
        room_types(*),
        properties(*)
      `)
      .order('created_at', { ascending: false })
    
    if (error) {
      console.error('Error fetching bookings:', error)
      throw new Error('Failed to load bookings')
    }
    
    return data
  },

  async updateBooking(id: string, updates: any) {
    const { data, error } = await supabaseAdmin
      .from('bookings')
      .update(updates)
      .eq('id', id)
      .select()
      .single()
    
    if (error) {
      console.error('Error updating booking:', error)
      throw new Error('Failed to update booking')
    }
    
    return data
  },

  // Menu management
  async createMenuItem(itemData: any) {
    const { data, error } = await supabaseAdmin
      .from('menu_items')
      .insert(itemData)
      .select()
      .single()
    
    if (error) {
      console.error('Error creating menu item:', error)
      throw new Error('Failed to create menu item')
    }
    
    return data
  },

  async updateMenuItem(id: string, updates: any) {
    const { data, error } = await supabaseAdmin
      .from('menu_items')
      .update(updates)
      .eq('id', id)
      .select()
      .single()
    
    if (error) {
      console.error('Error updating menu item:', error)
      throw new Error('Failed to update menu item')
    }
    
    return data
  },

  // Expense management
  async getAllExpenses() {
    const { data, error } = await supabaseAdmin
      .from('expenses')
      .select('*')
      .order('date', { ascending: false })
    
    if (error) {
      console.error('Error fetching expenses:', error)
      throw new Error('Failed to load expenses')
    }
    
    return data
  },

  async createExpense(expenseData: any) {
    const { data, error } = await supabaseAdmin
      .from('expenses')
      .insert(expenseData)
      .select()
      .single()
    
    if (error) {
      console.error('Error creating expense:', error)
      throw new Error('Failed to create expense')
    }
    
    return data
  },

  // Reports
  async getReports() {
    const { data, error } = await supabaseAdmin
      .from('reports')
      .select('*')
      .order('created_at', { ascending: false })
    
    if (error) {
      console.error('Error fetching reports:', error)
      throw new Error('Failed to load reports')
    }
    
    return data
  }
}

// Error handling wrapper for admin API calls
export const withAdminErrorHandling = <T extends any[], R>(
  fn: (...args: T) => Promise<R>
) => {
  return async (...args: T): Promise<R> => {
    try {
      // Check admin authentication before API call
      const isAdmin = await adminAuth.isAdmin()
      if (!isAdmin) {
        throw new Error('Admin authentication required')
      }
      
      return await fn(...args)
    } catch (error) {
      // Log error for monitoring
      console.error('Admin API Error:', {
        function: fn.name,
        args: args,
        error: error
      })
      
      // Handle authentication errors
      if (error instanceof Error && error.message.includes('JWT')) {
        // Redirect to login or refresh session
        throw new Error('Session expired. Please sign in again.')
      }
      
      // Re-throw with appropriate message
      if (error instanceof Error) {
        throw error
      }
      
      throw new Error('An unexpected error occurred')
    }
  }
}
```

### Client Factory and Management
```typescript
// lib/supabase/clientFactory.ts
import { supabasePublic } from './supabasePublic'
import { supabaseAdmin } from './supabaseAdmin'
import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '../types/database.types'

export type ClientType = 'public' | 'admin'

class SupabaseClientManager {
  private clients: Map<ClientType, SupabaseClient<Database>> = new Map()
  private currentClientType: ClientType = 'public'

  constructor() {
    this.clients.set('public', supabasePublic)
    this.clients.set('admin', supabaseAdmin)
  }

  getClient(type: ClientType): SupabaseClient<Database> {
    const client = this.clients.get(type)
    if (!client) {
      throw new Error(`Client type '${type}' not found`)
    }
    return client
  }

  getCurrentClient(): SupabaseClient<Database> {
    return this.getClient(this.currentClientType)
  }

  setCurrentClientType(type: ClientType): void {
    this.currentClientType = type
  }

  getCurrentClientType(): ClientType {
    return this.currentClientType
  }

  // Helper to determine appropriate client based on route
  getClientForRoute(pathname: string): SupabaseClient<Database> {
    if (pathname.startsWith('/admin')) {
      this.setCurrentClientType('admin')
      return this.getClient('admin')
    } else {
      this.setCurrentClientType('public')
      return this.getClient('public')
    }
  }

  // Clean up resources
  cleanup(): void {
    // Perform any necessary cleanup
    this.clients.clear()
  }
}

export const clientManager = new SupabaseClientManager()

// Convenience exports
export { supabasePublic, supabaseAdmin }
export const getSupabaseClient = (type: ClientType = 'public') => 
  clientManager.getClient(type)
```

### React Hook for Client Management
```typescript
// hooks/useSupabaseClient.ts
import { useRouter } from 'next/router'
import { useMemo } from 'react'
import { clientManager, type ClientType } from '../lib/supabase/clientFactory'
import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '../lib/types/database.types'

export function useSupabaseClient(forceType?: ClientType): SupabaseClient<Database> {
  const router = useRouter()
  
  return useMemo(() => {
    if (forceType) {
      return clientManager.getClient(forceType)
    }
    
    // Auto-determine client based on current route
    return clientManager.getClientForRoute(router.pathname)
  }, [router.pathname, forceType])
}

export function useClientType(): ClientType {
  const router = useRouter()
  
  return useMemo(() => {
    return router.pathname.startsWith('/admin') ? 'admin' : 'public'
  }, [router.pathname])
}

// Hook for public client specifically
export function usePublicClient(): SupabaseClient<Database> {
  return useSupabaseClient('public')
}

// Hook for admin client specifically
export function useAdminClient(): SupabaseClient<Database> {
  return useSupabaseClient('admin')
}
```

### Environment Configuration
```typescript
// lib/config/supabase.config.ts
interface SupabaseConfig {
  url: string
  anonKey: string
  serviceRoleKey?: string
  environment: 'development' | 'staging' | 'production'
}

function getSupabaseConfig(): SupabaseConfig {
  const url = import.meta.env.VITE_SUPABASE_URL
  const anonKey = import.meta.env.VITE_SUPABASE_ANON_KEY
  const serviceRoleKey = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY
  const environment = (import.meta.env.MODE as any) || 'development'

  if (!url || !anonKey) {
    throw new Error(
      'Missing required Supabase environment variables. ' +
      'Please check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY'
    )
  }

  return {
    url,
    anonKey,
    serviceRoleKey,
    environment
  }
}

export const supabaseConfig = getSupabaseConfig()

// Validation function
export function validateSupabaseConfig(): void {
  const config = supabaseConfig
  
  // Validate URL format
  try {
    new URL(config.url)
  } catch {
    throw new Error('Invalid Supabase URL format')
  }
  
  // Validate key format (basic check)
  if (!config.anonKey.startsWith('eyJ')) {
    throw new Error('Invalid Supabase anon key format')
  }
  
  // Environment-specific validations
  if (config.environment === 'production') {
    if (config.url.includes('localhost') || config.url.includes('127.0.0.1')) {
      throw new Error('Production environment cannot use localhost URLs')
    }
  }
}

// Initialize validation
validateSupabaseConfig()
```

### Migration Utilities
```typescript
// lib/migration/clientMigration.ts
import { supabaseAdmin } from '../supabase/supabaseAdmin'
import { supabasePublic } from '../supabase/supabasePublic'

// Migration helper to update existing code
export class ClientMigrationHelper {
  // Map old supabase calls to new client calls
  static migrateApiCall(operation: string, tableName: string) {
    const adminOnlyTables = [
      'expenses',
      'property_expenses', 
      'reports',
      'notifications',
      'user_roles',
      'admin_profiles'
    ]
    
    const publicReadTables = [
      'menu_items',
      'menu_categories',
      'room_types',
      'properties'
    ]
    
    const mixedAccessTables = [
      'bookings',
      'guest_profiles',
      'guests'
    ]
    
    // Determine appropriate client
    if (adminOnlyTables.includes(tableName)) {
      return 'admin'
    }
    
    if (publicReadTables.includes(tableName) && operation === 'select') {
      return 'public'
    }
    
    if (mixedAccessTables.includes(tableName)) {
      if (operation === 'select' || operation === 'insert') {
        return 'public' // Can use public for reads and guest creation
      }
      return 'admin' // Updates/deletes require admin
    }
    
    return 'admin' // Default to admin for safety
  }
  
  // Helper to replace old supabase imports
  static getReplacementImport(tableName: string, operation: string): string {
    const clientType = this.migrateApiCall(operation, tableName)
    
    if (clientType === 'admin') {
      return "import { supabaseAdmin as supabase } from '../lib/supabase/supabaseAdmin'"
    } else {
      return "import { supabasePublic as supabase } from '../lib/supabase/supabasePublic'"
    }
  }
}

// Validation helper
export async function validateClientMigration(): Promise<{
  publicClientWorking: boolean
  adminClientWorking: boolean
  errors: string[]
}> {
  const errors: string[] = []
  let publicClientWorking = false
  let adminClientWorking = false
  
  // Test public client
  try {
    await supabasePublic.from('menu_items').select('id').limit(1)
    publicClientWorking = true
  } catch (error) {
    errors.push(`Public client error: ${error}`)
  }
  
  // Test admin client
  try {
    const { data: { session } } = await supabaseAdmin.auth.getSession()
    if (session) {
      await supabaseAdmin.from('expenses').select('id').limit(1)
      adminClientWorking = true
    } else {
      errors.push('Admin client: No active session')
    }
  } catch (error) {
    errors.push(`Admin client error: ${error}`)
  }
  
  return {
    publicClientWorking,
    adminClientWorking,
    errors
  }
}
```

### Testing Infrastructure
```typescript
// __tests__/supabase/clientConfiguration.test.ts
import { supabasePublic, publicApi } from '../../lib/supabase/supabasePublic'
import { supabaseAdmin, adminAuth, adminApi } from '../../lib/supabase/supabaseAdmin'
import { clientManager } from '../../lib/supabase/clientFactory'

describe('Supabase Client Configuration', () => {
  describe('Public Client', () => {
    test('should be configured without session persistence', () => {
      expect(supabasePublic.auth.getSession).toBeDefined()
      // Test that session is not persisted
    })
    
    test('should allow access to public tables', async () => {
      const menuItems = await publicApi.getMenuItems()
      expect(Array.isArray(menuItems)).toBe(true)
    })
    
    test('should not allow access to admin tables', async () => {
      await expect(
        supabasePublic.from('expenses').select('*')
      ).rejects.toThrow()
    })
    
    test('should handle rate limiting', () => {
      // Test rate limiting functionality
    })
  })
  
  describe('Admin Client', () => {
    test('should be configured with session persistence', () => {
      expect(supabaseAdmin.auth.getSession).toBeDefined()
      // Test session persistence configuration
    })
    
    test('should require authentication for admin operations', async () => {
      // Test without authentication
      await expect(
        adminApi.getAllExpenses()
      ).rejects.toThrow('Admin authentication required')
    })
    
    test('should allow admin operations when authenticated', async () => {
      // Mock authenticated admin user
      // Test admin operations
    })
  })
  
  describe('Client Manager', () => {
    test('should return correct client for route', () => {
      const publicClient = clientManager.getClientForRoute('/menu')
      const adminClient = clientManager.getClientForRoute('/admin/dashboard')
      
      expect(publicClient).toBe(supabasePublic)
      expect(adminClient).toBe(supabaseAdmin)
    })
    
    test('should handle client switching', () => {
      clientManager.setCurrentClientType('admin')
      expect(clientManager.getCurrentClientType()).toBe('admin')
      
      clientManager.setCurrentClientType('public')
      expect(clientManager.getCurrentClientType()).toBe('public')
    })
  })
})
```

### Performance Monitoring
```typescript
// lib/monitoring/clientPerformance.ts
interface ClientMetrics {
  requestCount: number
  averageResponseTime: number
  errorRate: number
  lastError?: string
}

class ClientPerformanceMonitor {
  private metrics: Map<string, ClientMetrics> = new Map()
  
  recordRequest(clientType: string, responseTime: number, success: boolean, error?: string) {
    const current = this.metrics.get(clientType) || {
      requestCount: 0,
      averageResponseTime: 0,
      errorRate: 0
    }
    
    current.requestCount++
    current.averageResponseTime = 
      (current.averageResponseTime * (current.requestCount - 1) + responseTime) / current.requestCount
    
    if (!success) {
      current.errorRate = (current.errorRate * (current.requestCount - 1) + 1) / current.requestCount
      current.lastError = error
    } else {
      current.errorRate = (current.errorRate * (current.requestCount - 1)) / current.requestCount
    }
    
    this.metrics.set(clientType, current)
  }
  
  getMetrics(clientType: string): ClientMetrics | undefined {
    return this.metrics.get(clientType)
  }
  
  getAllMetrics(): Record<string, ClientMetrics> {
    return Object.fromEntries(this.metrics)
  }
}

export const performanceMonitor = new ClientPerformanceMonitor()

// Wrapper to add performance monitoring
export function withPerformanceMonitoring<T extends any[], R>(
  clientType: string,
  fn: (...args: T) => Promise<R>
) {
  return async (...args: T): Promise<R> => {
    const startTime = Date.now()
    
    try {
      const result = await fn(...args)
      const responseTime = Date.now() - startTime
      
      performanceMonitor.recordRequest(clientType, responseTime, true)
      return result
    } catch (error) {
      const responseTime = Date.now() - startTime
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      
      performanceMonitor.recordRequest(clientType, responseTime, false, errorMessage)
      throw error
    }
  }
}
```

### Documentation and Migration Guide
```markdown
# Dual Supabase Client Migration Guide

## Overview
This guide covers migrating from a single Supabase client to dual client configuration.

## Client Types

### Public Client (`supabasePublic`)
- **Purpose**: Customer-facing features
- **Authentication**: None (anonymous access)
- **Tables**: menu_items, menu_categories, room_types, properties
- **Operations**: Read-only + booking creation

### Admin Client (`supabaseAdmin`)
- **Purpose**: Admin panel functionality
- **Authentication**: Full authentication with session persistence
- **Tables**: All tables with appropriate permissions
- **Operations**: Full CRUD based on RLS policies

## Migration Steps

1. **Update Imports**
   ```typescript
   // Old
   import { supabase } from '../lib/supabase'
   
   // New - Public client
   import { supabasePublic } from '../lib/supabase/supabasePublic'
   
   // New - Admin client
   import { supabaseAdmin } from '../lib/supabase/supabaseAdmin'
   ```

2. **Update API Calls**
   ```typescript
   // Old
   const { data } = await supabase.from('menu_items').select('*')
   
   // New - Public
   const { data } = await supabasePublic.from('menu_items').select('*')
   
   // New - Admin
   const { data } = await supabaseAdmin.from('expenses').select('*')
   ```

3. **Use Helper Functions**
   ```typescript
   // Use pre-built API helpers
   import { publicApi } from '../lib/supabase/supabasePublic'
   import { adminApi } from '../lib/supabase/supabaseAdmin'
   
   const menuItems = await publicApi.getMenuItems()
   const expenses = await adminApi.getAllExpenses()
   ```

## Best Practices

1. **Route-based Client Selection**
   - Use public client for customer-facing pages
   - Use admin client for `/admin/*` routes

2. **Error Handling**
   - Use provided error handling wrappers
   - Implement proper fallbacks

3. **Performance**
   - Cache client instances
   - Use appropriate client for each operation

4. **Security**
   - Never use admin client in public contexts
   - Validate authentication before admin operations
```

### Testing Checklist
- [ ] Public client can access menu items without authentication
- [ ] Public client can create bookings and guest profiles
- [ ] Public client cannot access admin-only tables
- [ ] Admin client requires authentication for all operations
- [ ] Admin client can access all tables when authenticated
- [ ] Client switching works correctly based on routes
- [ ] Error handling works for both clients
- [ ] Performance monitoring captures metrics
- [ ] Rate limiting works for public client
- [ ] Session persistence works for admin client
- [ ] PKCE flow works for admin authentication
- [ ] Client isolation prevents data leakage
- [ ] Bundle splitting separates client code
- [ ] Environment configuration works correctly
- [ ] Migration utilities work as expected

### Rollback Plan
1. Revert to single client configuration
2. Update all imports back to original supabase client
3. Remove dual client files
4. Update environment variables if needed
5. Test all functionality with single client
6. Monitor for any issues post-rollback