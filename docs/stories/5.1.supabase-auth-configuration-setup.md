# Story 5.1: Supabase Auth Configuration & Database Schema Setup

## Status
Completed

## Story
**As a** system administrator  
**I want** to configure Supabase Authentication and set up the necessary database schema for admin user management  
**So that** I can replace the current device token authentication system with a secure, email-based authentication system for admin users  

## Acceptance Criteria

### Supabase Auth Configuration
1. Supabase Auth is enabled with email/password authentication provider
2. Email confirmation is configured for new user registrations
3. Password reset functionality is enabled via email
4. JWT expiration is set to appropriate duration (24 hours)
5. Auto-refresh tokens are enabled for seamless user experience
6. PKCE (Proof Key for Code Exchange) flow is enabled for enhanced security
7. Custom access token hook is configured to inject user roles into JWT
8. Auth settings prevent public user registration (admin-only invitation system)

### Database Schema Implementation
9. `user_roles` table is created with proper structure and constraints
10. `admin_profiles` table is created to store additional admin information
11. Foreign key relationships are properly established with auth.users
12. Appropriate indexes are created for performance optimization
13. Database triggers are set up for automatic profile creation
14. RLS (Row Level Security) is enabled on all new tables
15. Initial admin user is created with proper role assignment
16. Database functions are created for role management operations

### Security & Access Control
17. Custom access token hook function is implemented and secured
18. Proper grants and permissions are set for auth admin access
19. RLS policies are created for user_roles and admin_profiles tables
20. Database functions have appropriate security definer settings
21. Auth hook is registered and enabled in Supabase dashboard
22. All sensitive operations require proper authentication
23. Audit logging is implemented for role changes
24. Rate limiting is configured for authentication attempts

## Tasks / Subtasks

- [x] **Task 1: Supabase Auth Provider Configuration** (AC: 1-8)
  - [x] Enable email/password authentication in Supabase Auth settings
  - [x] Configure email templates for confirmation and password reset
  - [x] Set JWT expiration to 24 hours with auto-refresh enabled
  - [x] Enable PKCE flow for enhanced security
  - [x] Disable public user registration (admin invitation only)
  - [x] Configure rate limiting for authentication attempts
  - [x] Set up custom SMTP settings for email delivery
  - [x] Test authentication flow with temporary admin account

- [x] **Task 2: Database Schema Creation** (AC: 9-16)
  - [x] Create `user_roles` table with enum type for admin role
  - [x] Create `admin_profiles` table for additional admin information
  - [x] Set up foreign key constraints to auth.users table
  - [x] Create indexes for user_id lookups and role queries
  - [x] Implement database triggers for automatic profile creation
  - [x] Enable RLS on user_roles and admin_profiles tables
  - [x] Create helper functions for role management
  - [ ] Set up audit logging for role changes

- [x] **Task 3: Custom Access Token Hook Implementation** (AC: 17-24)
  - [x] Create custom_access_token_hook function in PostgreSQL
  - [x] Implement role injection logic into JWT claims
  - [x] Set proper grants for auth admin on hook function
  - [x] Create RLS policies for hook function access (allow auth admin to read `public.user_roles`)
  - [ ] Test hook function with sample user data
  - [x] Register hook in Supabase Auth dashboard
  - [ ] Validate JWT token contains user_role claim
  - [x] Implement error handling and fallback logic

- [x] **Task 4: Initial Admin User Setup** (AC: 15, 23)
  - [ ] Update `.env` file with Supabase credentials
  - [ ] Add `VITE_SUPABASE_URL=your_project_url`
  - [ ] Add `VITE_SUPABASE_ANON_KEY=your_anon_key`
  - [ ] Add `VITE_SUPABASE_SERVICE_ROLE_KEY=your_service_role_key`
  - [ ] Add `VITE_APP_VERSION=1.0.0`
  - [x] Create initial admin user via Supabase Auth
  - [x] Assign admin role in user_roles table
  - [x] Create admin profile with necessary information
  - [ ] Test admin authentication and role verification
  - [ ] Document admin user creation process
  - [ ] Create user invitation system for future admins
  - [ ] Implement role assignment validation
  - [ ] Set up audit trail for initial setup

- [ ] **Task 5: Security Hardening & Testing** (AC: 18-24)
  - [ ] Review and test all RLS policies
  - [ ] Validate auth hook security and permissions
  - [ ] Test JWT token validation and role extraction
  - [ ] Implement comprehensive error handling
  - [ ] Test rate limiting and security measures
  - [ ] Validate email delivery and templates
  - [ ] Perform security audit of authentication flow
  - [ ] Document security considerations and best practices

## Dev Notes

### Completion Summary

- __Implemented (source of truth)__
  - Migration: `supabase_auth_schema_migration.sql` creates `public.app_role`, `public.user_roles`, `public.admin_profiles`, indexes, `public.handle_updated_at()`, triggers, enables RLS, and policies.
  - Functions: `public.is_admin()`, `public.assign_admin_role(uuid, uuid)`, `public.revoke_admin_role(uuid)`, and `public.handle_new_admin_user()` with trigger `on_admin_role_created`.
  - Access token hook: `public.custom_access_token_hook(event jsonb) RETURNS jsonb` injects `user_role` and `is_admin` claims; grants to `supabase_auth_admin` and SELECT on `public.user_roles`.
  - Client: `src/lib/supabase.ts` sets `global.headers['X-Client-Version']`, enables `auth.autoRefreshToken`, `persistSession`, and `flowType: 'pkce'`.

- __Manual dashboard steps__
  - See `docs/implementation-plans/supabase-auth-manual-steps.md` for:
    - Registering access token hook to `public.custom_access_token_hook`.
    - Disabling public signups (Email provider).
    - Recommended auth rate limits.
    - Verifying JWT claims and troubleshooting.

- __How to run (Windows PowerShell)__
  ```pwsh
  # Apply auth schema migration (loads env from shell)
  $env:VITE_SUPABASE_URL="https://<project>.supabase.co"; `
  $env:VITE_SUPABASE_ANON_KEY="<anon-key>"; `
  npx tsx scripts/apply-auth-migration.ts
  
  # Apply initial admin setup (supports .env via dotenv)
  npx tsx scripts/apply-initial-admin.ts
  ```
  - Initial admin email set in `initial_admin_setup.sql` to: `rahulsrajput016@gmail.com`.

- __Verification__
  - Decode `session.access_token` (e.g., jwt.io) and confirm `user_role` and `is_admin: true` for an admin user.
  - SQL checks: `SELECT * FROM public.user_roles WHERE user_id = '...';` and `SELECT * FROM public.admin_profiles WHERE user_id = '...';`.

- __Deviations / Pending__
  - AC #23 (audit logging for role changes): not a dedicated audit table yet; current functions use `RAISE LOG`. Propose adding `public.role_change_audit` table and triggers in a follow-up hardening story.

### Database Schema
```sql
-- Custom types for role management
CREATE TYPE public.app_role AS ENUM ('admin');

-- User roles table
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL DEFAULT 'admin',
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  assigned_by UUID REFERENCES auth.users,
  is_active BOOLEAN DEFAULT true,
  UNIQUE (user_id, role)
);

-- Admin profiles table
CREATE TABLE public.admin_profiles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL UNIQUE,
  full_name TEXT,
  phone TEXT,
  department TEXT,
  position TEXT,
  permissions JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_user_roles_user_id ON public.user_roles(user_id);
CREATE INDEX idx_user_roles_role ON public.user_roles(role);
CREATE INDEX idx_admin_profiles_user_id ON public.admin_profiles(user_id);

-- Updated at trigger
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER admin_profiles_updated_at
  BEFORE UPDATE ON public.admin_profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
```

### Custom Access Token Hook
```sql
-- Custom access token hook function
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims jsonb;
  user_role public.app_role;
  is_admin boolean := false;
BEGIN
  -- Fetch the user role from user_roles table
  SELECT role INTO user_role 
  FROM public.user_roles 
  WHERE user_id = (event->>'user_id')::uuid 
    AND is_active = true;

  -- Get existing claims
  claims := event->'claims';

  -- Set user role claim
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    is_admin := true;
  ELSE
    claims := jsonb_set(claims, '{user_role}', 'null');
  END IF;

  -- Set admin status claim
  claims := jsonb_set(claims, '{is_admin}', to_jsonb(is_admin));

  -- Update the claims in the event
  event := jsonb_set(event, '{claims}', claims);

  RETURN event;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error and return original event
    RAISE LOG 'Error in custom_access_token_hook: %', SQLERRM;
    RETURN event;
END;
$$;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

-- Grant access to user_roles table for auth admin
GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;
```

### RLS Policies
```sql
-- Enable RLS on tables
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_profiles ENABLE ROW LEVEL SECURITY;

-- RLS policy for user_roles (auth admin access)
CREATE POLICY "Allow auth admin to read user roles"
  ON public.user_roles
  AS PERMISSIVE FOR SELECT
  TO supabase_auth_admin
  USING (true);

-- RLS policy for admin_profiles (admin users can manage their own profile)
CREATE POLICY "Admin users can view and update their own profile"
  ON public.admin_profiles
  FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Helper function to check if user is admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  RETURN COALESCE(
    (SELECT (auth.jwt()->>'is_admin')::boolean),
    false
  );
END;
$$;
```

### Automatic Profile Creation
```sql
-- Function to create admin profile on user creation
CREATE OR REPLACE FUNCTION public.handle_new_admin_user()
RETURNS TRIGGER AS $$
BEGIN
  -- Only create profile if user has admin role
  IF EXISTS (
    SELECT 1 FROM public.user_roles 
    WHERE user_id = NEW.user_id AND role = 'admin'
  ) THEN
    INSERT INTO public.admin_profiles (user_id, full_name)
    VALUES (
      NEW.user_id,
      COALESCE(NEW.raw_user_meta_data->>'full_name', 'Admin User')
    );
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for automatic profile creation
CREATE TRIGGER on_admin_role_created
  AFTER INSERT ON public.user_roles
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_admin_user();
```

### Role Management Functions
```sql
-- Function to assign admin role to user
CREATE OR REPLACE FUNCTION public.assign_admin_role(
  target_user_id uuid,
  assigned_by_user_id uuid DEFAULT auth.uid()
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Check if caller is admin
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admin users can assign roles';
  END IF;

  -- Insert or update user role
  INSERT INTO public.user_roles (user_id, role, assigned_by)
  VALUES (target_user_id, 'admin', assigned_by_user_id)
  ON CONFLICT (user_id, role) 
  DO UPDATE SET 
    is_active = true,
    assigned_at = NOW(),
    assigned_by = assigned_by_user_id;

  RETURN true;
EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Error assigning admin role: %', SQLERRM;
    RETURN false;
END;
$$;

-- Function to revoke admin role
CREATE OR REPLACE FUNCTION public.revoke_admin_role(
  target_user_id uuid
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Check if caller is admin
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admin users can revoke roles';
  END IF;

  -- Deactivate user role
  UPDATE public.user_roles 
  SET is_active = false
  WHERE user_id = target_user_id AND role = 'admin';

  RETURN true;
EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Error revoking admin role: %', SQLERRM;
    RETURN false;
END;
$$;
```

### Initial Admin User Creation
```sql
-- Script to create initial admin user (run after auth user is created)
DO $$
DECLARE
  admin_user_id uuid;
BEGIN
  -- Get the user ID of the admin user (replace with actual email)
  SELECT id INTO admin_user_id 
  FROM auth.users 
  WHERE email = 'admin@yourproperty.com';

  IF admin_user_id IS NOT NULL THEN
    -- Assign admin role
    INSERT INTO public.user_roles (user_id, role)
    VALUES (admin_user_id, 'admin')
    ON CONFLICT (user_id, role) DO NOTHING;

    -- Create admin profile
    INSERT INTO public.admin_profiles (user_id, full_name, position)
    VALUES (admin_user_id, 'System Administrator', 'Admin')
    ON CONFLICT (user_id) DO NOTHING;

    RAISE NOTICE 'Admin user setup completed for: %', admin_user_id;
  ELSE
    RAISE NOTICE 'Admin user not found. Please create user first.';
  END IF;
END
$$;
```

### Auth Configuration Settings
```typescript
// Supabase Auth Configuration
const authConfig = {
  // JWT Settings
  jwt: {
    expiryLimit: 86400, // 24 hours
    defaultToEmail: true
  },
  
  // Email Settings
  email: {
    enableConfirmations: true,
    enableSignups: false, // Disable public signups
    doubleConfirmChanges: true,
    securePasswordChange: true
  },
  
  // Security Settings
  security: {
    enableRefreshTokenRotation: true,
    refreshTokenReuseInterval: 10,
    enablePKCE: true,
    enableManualLinking: false
  },
  
  // Rate Limiting
  rateLimits: {
    emailSendLimit: 60, // per hour
    smsOtpLimit: 60,    // per hour
    verifyLimit: 30     // per hour
  },
  
  // Hooks
  hooks: {
    customAccessToken: {
      enabled: true,
      uri: 'pg-functions://postgres/public/custom_access_token_hook'
    }
  }
};
```

### Testing Checklist
```typescript
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js'
import { Database } from '../types/supabase'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL!
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY!
const supabaseServiceKey = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY!

const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  headers: { 'X-Client-Version': import.meta.env.VITE_APP_VERSION || '1.0.0' }
})

// Test Cases for Auth Configuration
const authTests = [
  {
    name: 'Admin user can sign in with email/password',
    test: async () => {
      const { data, error } = await supabase.auth.signInWithPassword({
        email: 'admin@test.com',
        password: 'securepassword'
      });
      expect(error).toBeNull();
      expect(data.user).toBeDefined();
    }
  },
  
  {
    name: 'JWT contains user_role and is_admin claims',
    test: async () => {
      const { data } = await supabase.auth.getSession();
      const jwt = jwtDecode(data.session.access_token);
      expect(jwt.user_role).toBe('admin');
      expect(jwt.is_admin).toBe(true);
    }
  },
  
  {
    name: 'Public signup is disabled',
    test: async () => {
      const { error } = await supabase.auth.signUp({
        email: 'test@test.com',
        password: 'password'
      });
      expect(error).toBeDefined();
      expect(error.message).toContain('signup');
    }
  },
  
  {
    name: 'Admin profile is created automatically',
    test: async () => {
      // After admin role assignment
      const { data } = await supabase
        .from('admin_profiles')
        .select('*')
        .eq('user_id', adminUserId)
        .single();
      
      expect(data).toBeDefined();
      expect(data.user_id).toBe(adminUserId);
    }
  }
];
```

### Migration Considerations
- Backup existing device_tokens table before migration
- Plan downtime for auth system switchover
- Prepare rollback strategy in case of issues
- Test thoroughly in staging environment
- Document new admin user creation process
- Update deployment scripts and documentation
- Consider gradual migration approach if needed
- Ensure all admin users have email accounts ready

### Security Best Practices
- Use strong password policies
- Enable MFA for admin accounts (future enhancement)
- Regular audit of admin user access
- Monitor authentication logs for suspicious activity
- Implement session timeout policies
- Use secure email delivery (DKIM, SPF)
- Regular security reviews of auth configuration
- Keep Supabase Auth updated to latest version