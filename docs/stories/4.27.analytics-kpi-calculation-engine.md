# Story 4.27: KPI Calculation Engine

## Status
Ready for Development

## Story
**As a** property manager  
**I want** accurate KPI calculations from real business data  
**So that** I can track performance metrics and make data-driven decisions  

## Acceptance Criteria
1. Calculate core KPIs: Revenue, Occupancy Rate, ADR, RevPAR
2. Calculate performance metrics: Booking conversion, cancellation rate
3. Calculate guest metrics: Repeat guest rate, average length of stay
4. Support multi-property aggregated KPIs
5. Provide period-over-period comparisons (MoM, YoY)
6. Calculate trend indicators (up/down/stable)
7. Handle edge cases (zero bookings, partial data)
8. Provide confidence scores for calculated metrics

## Tasks / Subtasks

- [ ] **Task 1: Create KPI Calculator Core** (AC: 1, 7)
  - [ ] Create src/services/analytics/KPICalculator.ts
  - [ ] Implement CoreKPICalculator class
  - [ ] Define KPI interfaces and types
  - [ ] Add calculation methods for each core KPI
  - [ ] Implement error handling for edge cases

- [ ] **Task 2: Revenue Metrics Implementation** (AC: 1, 4)
  - [ ] Implement calculateTotalRevenue method
  - [ ] Create calculateADR (Average Daily Rate) method
  - [ ] Implement calculateRevPAR (Revenue Per Available Room)
  - [ ] Add revenue breakdown by source/channel
  - [ ] Implement multi-property revenue aggregation

- [ ] **Task 3: Occupancy Metrics Implementation** (AC: 1, 4)
  - [ ] Create calculateOccupancyRate method
  - [ ] Implement room nights calculation
  - [ ] Add available rooms calculation
  - [ ] Create occupancy heat map data generator
  - [ ] Implement seasonal occupancy patterns

- [ ] **Task 4: Performance Metrics** (AC: 2, 3)
  - [ ] Implement booking conversion rate calculation
  - [ ] Create cancellation rate calculator
  - [ ] Add average length of stay calculator
  - [ ] Implement repeat guest rate calculation
  - [ ] Create booking lead time analysis

- [ ] **Task 5: Comparison and Trends** (AC: 5, 6, 8)
  - [ ] Implement period comparison calculator
  - [ ] Create trend detection algorithm
  - [ ] Add growth rate calculations
  - [ ] Implement moving averages
  - [ ] Create confidence score calculator


## Dev Notes

### KPI Formulas
```typescript
// Core KPI Calculations
interface KPIFormulas {
  // Revenue Metrics
  totalRevenue: (bookings: Booking[]) => number;
  // Sum of all confirmed booking amounts
  
  averageDailyRate: (revenue: number, roomNightsSold: number) => number;
  // ADR = Total Room Revenue / Number of Rooms Sold
  
  revPAR: (revenue: number, availableRooms: number) => number;
  // RevPAR = Total Room Revenue / Total Available Rooms
  // OR: ADR × Occupancy Rate
  
  // Occupancy Metrics
  occupancyRate: (occupiedRooms: number, availableRooms: number) => number;
  // Occupancy = (Rooms Occupied / Rooms Available) × 100
  
  // Performance Metrics
  conversionRate: (confirmed: number, inquiries: number) => number;
  // Conversion = (Confirmed Bookings / Total Inquiries) × 100
  
  cancellationRate: (cancelled: number, total: number) => number;
  // Cancellation = (Cancelled Bookings / Total Bookings) × 100
  
  // Guest Metrics
  repeatGuestRate: (repeatGuests: number, totalGuests: number) => number;
  // Repeat = (Returning Guests / Total Unique Guests) × 100
  
  averageLOS: (totalNights: number, totalBookings: number) => number;
  // ALOS = Total Guest Nights / Total Number of Bookings
}
```

### Implementation Example
```typescript
export class KPICalculator {
  constructor(
    private data: AnalyticsData,
    private config: KPIConfig
  ) {}

  calculateRevenue(): RevenueMetrics {
    const confirmedBookings = this.data.bookings.filter(b => !b.cancelled);
    
    const totalRevenue = confirmedBookings.reduce(
      (sum, booking) => sum + booking.total_amount, 
      0
    );
    
    const roomNightsSold = this.calculateRoomNights(confirmedBookings);
    const availableRooms = this.calculateAvailableRooms();
    
    const adr = roomNightsSold > 0 
      ? totalRevenue / roomNightsSold 
      : 0;
    
    const revpar = availableRooms > 0 
      ? totalRevenue / availableRooms 
      : 0;
    
    return {
      total: totalRevenue,
      adr: this.round(adr, 2),
      revpar: this.round(revpar, 2),
      breakdown: this.calculateRevenueBreakdown(confirmedBookings),
      confidence: this.calculateConfidence(confirmedBookings.length)
    };
  }

  calculateOccupancy(): OccupancyMetrics {
    const occupiedNights = this.calculateOccupiedRoomNights();
    const availableNights = this.calculateAvailableRoomNights();
    
    const occupancyRate = availableNights > 0
      ? (occupiedNights / availableNights) * 100
      : 0;
    
    return {
      rate: this.round(occupancyRate, 1),
      occupiedNights,
      availableNights,
      pattern: this.detectOccupancyPattern(),
      forecast: this.forecastOccupancy()
    };
  }

  private calculateConfidence(sampleSize: number): number {
    // Statistical confidence based on sample size
    if (sampleSize < 10) return 0.5;
    if (sampleSize < 50) return 0.7;
    if (sampleSize < 100) return 0.85;
    if (sampleSize < 500) return 0.95;
    return 0.99;
  }
}
```

### Period Comparison
```typescript
export class PeriodComparator {
  comparePeriods(
    current: KPIMetrics,
    previous: KPIMetrics
  ): PeriodComparison {
    return {
      revenue: {
        current: current.revenue.total,
        previous: previous.revenue.total,
        change: this.calculateChange(current.revenue.total, previous.revenue.total),
        trend: this.detectTrend(current.revenue.total, previous.revenue.total)
      },
      occupancy: {
        current: current.occupancy.rate,
        previous: previous.occupancy.rate,
        change: this.calculateChange(current.occupancy.rate, previous.occupancy.rate),
        trend: this.detectTrend(current.occupancy.rate, previous.occupancy.rate)
      },
      // ... other metrics
    };
  }

  private calculateChange(current: number, previous: number): ChangeMetrics {
    const absolute = current - previous;
    const percentage = previous !== 0 
      ? ((current - previous) / previous) * 100 
      : 0;
    
    return {
      absolute,
      percentage: this.round(percentage, 1),
      direction: absolute > 0 ? 'up' : absolute < 0 ? 'down' : 'stable'
    };
  }

  private detectTrend(values: number[]): TrendType {
    // Simple trend detection using linear regression
    const slope = this.calculateSlope(values);
    const threshold = 0.05; // 5% change threshold
    
    if (Math.abs(slope) < threshold) return 'stable';
    return slope > 0 ? 'up' : 'down';
  }
}
```

### Edge Case Handling
```typescript
const edgeCaseHandlers = {
  noBookings: () => ({
    revenue: 0,
    occupancy: 0,
    adr: 0,
    revpar: 0,
    confidence: 0,
    message: 'No bookings in selected period'
  }),
  
  partialData: (available: number, required: number) => ({
    confidence: available / required,
    warning: `Only ${available} of ${required} data points available`
  }),
  
  divisionByZero: (numerator: number, denominator: string) => ({
    value: 0,
    error: `Cannot calculate: ${denominator} is zero`,
    fallback: 0
  }),
  
  outlierDetection: (value: number, mean: number, stdDev: number) => {
    const zScore = Math.abs((value - mean) / stdDev);
    return {
      isOutlier: zScore > 3,
      confidence: Math.max(0, 1 - (zScore / 10))
    };
  }
};
```

### Multi-Property Aggregation
```typescript
export class MultiPropertyAggregator {
  aggregateKPIs(propertyKPIs: Map<string, KPIMetrics>): AggregatedKPIs {
    const properties = Array.from(propertyKPIs.values());
    
    return {
      total: {
        revenue: this.sumMetric(properties, 'revenue.total'),
        bookings: this.sumMetric(properties, 'bookings.count'),
        occupancy: this.weightedAverage(
          properties.map(p => ({
            value: p.occupancy.rate,
            weight: p.rooms.available
          }))
        )
      },
      byProperty: propertyKPIs,
      topPerformers: this.identifyTopPerformers(propertyKPIs),
      insights: this.generateComparativeInsights(propertyKPIs)
    };
  }

  private weightedAverage(items: {value: number, weight: number}[]): number {
    const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
    const weightedSum = items.reduce(
      (sum, item) => sum + (item.value * item.weight), 
      0
    );
    return totalWeight > 0 ? weightedSum / totalWeight : 0;
  }
}
```

### Performance Optimizations
- Cache calculated KPIs with TTL
- Use memoization for expensive calculations
- Implement incremental updates for real-time data
- Use Web Workers for complex calculations
- Batch calculations for multiple properties

### Validation Rules
```typescript
const validationRules = {
  percentage: (value: number) => value >= 0 && value <= 100,
  revenue: (value: number) => value >= 0,
  occupancy: (value: number) => value >= 0 && value <= 100,
  confidence: (value: number) => value >= 0 && value <= 1,
  trend: (value: string) => ['up', 'down', 'stable'].includes(value)
};
```


## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation | Analytics Team |

---

## Linked Issues
- Depends on: Story 4.26 (Data Service Layer)
- Blocks: Stories 4.29-4.31 (Analytics Integration)
- Related: All analytics dashboard stories
