# Story 4.26: Supabase Data Service Layer

## Status
Ready for Development

## Story
**As a** property manager  
**I want** the analytics dashboard to display real data from Supabase  
**So that** I can make informed decisions based on actual business metrics rather than mock data  

## Acceptance Criteria
1. Service layer connects to Supabase and fetches real booking data
2. Service layer connects to expense data from expense tracking system
3. Service layer aggregates data from multiple properties if user has access
4. Data fetching is optimized with proper caching and pagination
5. Error handling provides graceful fallbacks and user feedback
6. Service layer supports date range filtering
7. Service layer supports property-specific filtering
8. All sensitive data is properly secured with RLS policies

## Tasks / Subtasks

- [ ] **Task 1: Create Analytics Service Architecture** (AC: 1, 2, 3)
  - [ ] Create src/services/analytics/AnalyticsService.ts
  - [ ] Implement DataAggregator.ts for combining data sources
  - [ ] Create TypeScript interfaces for analytics data types
  - [ ] Implement service orchestration pattern
  - [ ] Add dependency injection for testability

- [ ] **Task 2: Implement Booking Data Integration** (AC: 1, 4, 6, 7)
  - [ ] Create BookingAnalyticsService.ts
  - [ ] Implement fetchBookingsByDateRange method
  - [ ] Add fetchBookingsByProperty method
  - [ ] Create aggregation functions for booking metrics
  - [ ] Implement pagination for large datasets

- [ ] **Task 3: Implement Expense Data Integration** (AC: 2, 4, 6, 7)
  - [ ] Create ExpenseAnalyticsService.ts
  - [ ] Connect to existing ExpenseService
  - [ ] Implement expense categorization logic
  - [ ] Add expense trend calculation methods
  - [ ] Create expense aggregation by property

- [ ] **Task 4: Implement Caching Strategy** (AC: 4)
  - [ ] Create CacheManager.ts with React Query integration
  - [ ] Implement cache invalidation strategies
  - [ ] Add stale-while-revalidate patterns
  - [ ] Create cache warming for common queries
  - [ ] Implement IndexedDB for offline caching

- [ ] **Task 5: Security and Error Handling** (AC: 5, 8)
  - [ ] Implement RLS policy verification
  - [ ] Add request retry logic with exponential backoff
  - [ ] Create comprehensive error boundaries
  - [ ] Implement logging with SecureLogger
  - [ ] Add performance monitoring

- [ ] **Task 6: Testing** (AC: All)
  - [ ] Write unit tests for all service methods
  - [ ] Create integration tests with Supabase
  - [ ] Test error scenarios and fallbacks
  - [ ] Validate data aggregation accuracy
  - [ ] Performance test with large datasets

## Dev Notes

### Data Models
**Analytics Service Response Structure**:
```typescript
interface AnalyticsData {
  period: {
    start: Date;
    end: Date;
  };
  properties: string[];
  bookings: {
    total: number;
    confirmed: number;
    cancelled: number;
    data: Booking[];
  };
  expenses: {
    total: number;
    byCategory: Record<string, number>;
    data: Expense[];
  };
  revenue: {
    total: number;
    bySource: Record<string, number>;
    byProperty: Record<string, number>;
  };
  occupancy: {
    rate: number;
    roomNights: number;
    availableRooms: number;
  };
  metadata: {
    fetchedAt: Date;
    cacheStatus: 'hit' | 'miss' | 'stale';
    queryTime: number;
  };
}
```

### Service Architecture
```typescript
// Main Analytics Service
class AnalyticsService {
  constructor(
    private bookingService: BookingAnalyticsService,
    private expenseService: ExpenseAnalyticsService,
    private cacheManager: CacheManager
  ) {}

  async fetchAnalytics(params: AnalyticsParams): Promise<AnalyticsData> {
    // Orchestrate data fetching
    // Apply caching strategies
    // Aggregate results
  }
}

// Booking Analytics Service
class BookingAnalyticsService {
  async fetchBookings(params: BookingParams): Promise<BookingData> {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .gte('check_in', params.startDate)
      .lte('check_out', params.endDate)
      .eq('property_id', params.propertyId);
    
    if (error) throw new AnalyticsError(error);
    return this.processBookingData(data);
  }
}
```

### Caching Strategy
```typescript
const cacheConfig = {
  bookings: {
    staleTime: 5 * 60 * 1000,      // 5 minutes
    cacheTime: 30 * 60 * 1000,     // 30 minutes
    refetchInterval: 5 * 60 * 1000  // 5 minutes
  },
  expenses: {
    staleTime: 10 * 60 * 1000,     // 10 minutes
    cacheTime: 60 * 60 * 1000,     // 1 hour
    refetchInterval: false          // Manual refetch only
  },
  kpis: {
    staleTime: 1 * 60 * 1000,       // 1 minute
    cacheTime: 10 * 60 * 1000,     // 10 minutes
    refetchInterval: 1 * 60 * 1000  // 1 minute
  }
};
```

### Supabase Queries
**Optimized Booking Query**:
```sql
-- Get bookings with aggregations
SELECT 
  COUNT(*) as total_bookings,
  SUM(total_amount) as total_revenue,
  AVG(total_amount) as avg_booking_value,
  COUNT(CASE WHEN cancelled = true THEN 1 END) as cancelled_bookings,
  property_id,
  DATE_TRUNC('day', check_in) as booking_date
FROM bookings
WHERE 
  check_in >= $1 
  AND check_out <= $2
  AND property_id = ANY($3)
GROUP BY property_id, booking_date
ORDER BY booking_date DESC;
```

### Error Handling
```typescript
class AnalyticsError extends Error {
  constructor(
    message: string,
    public code: string,
    public context?: any
  ) {
    super(message);
    this.name = 'AnalyticsError';
  }
}

const errorHandlers = {
  NETWORK_ERROR: async (error: Error) => {
    // Retry with exponential backoff
    // Fall back to cached data
    // Show user notification
  },
  PERMISSION_ERROR: async (error: Error) => {
    // Log security event
    // Redirect to login
    // Clear invalid cache
  },
  DATA_ERROR: async (error: Error) => {
    // Log to monitoring
    // Use partial data
    // Show degraded UI
  }
};
```

### Performance Optimizations
- Use database views for complex aggregations
- Implement query result pagination
- Use React Query for intelligent caching
- Batch multiple queries when possible
- Implement virtual scrolling for large datasets
- Use Web Workers for heavy calculations

### Security Requirements
- All queries must respect RLS policies
- Implement request signing for API calls
- Sanitize all user inputs
- Use parameterized queries
- Implement rate limiting
- Add audit logging for data access

## Testing

### Test Requirements
- **Unit Tests**: Service methods, data transformations, error handling
- **Integration Tests**: Supabase connections, data aggregation accuracy
- **Performance Tests**: Query optimization, caching effectiveness
- **Security Tests**: RLS enforcement, data isolation

### Test Files
- `tests/unit/services/analytics/AnalyticsService.test.ts`
- `tests/integration/analytics-data-fetching.test.ts`
- `tests/performance/analytics-query-performance.test.ts`
- `tests/security/analytics-rls-policies.test.ts`

### Test Scenarios
```typescript
describe('AnalyticsService', () => {
  describe('fetchAnalytics', () => {
    it('should fetch and aggregate booking data correctly');
    it('should handle multiple property filtering');
    it('should respect date range boundaries');
    it('should use cache when available');
    it('should handle network errors gracefully');
    it('should enforce RLS policies');
  });
  
  describe('Performance', () => {
    it('should complete queries under 500ms');
    it('should handle 10,000 bookings efficiently');
    it('should batch requests optimally');
  });
});
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation | Analytics Team |

---

## Linked Issues
- Depends on: Existing booking and expense services
- Blocks: Stories 4.27-4.35 (All analytics features)
- Related: Story 4.0 (Analytics Foundation)
