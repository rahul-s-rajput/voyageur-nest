# Story 5.6: Device Token Migration & Cleanup

## Status
Ready for Development

## Story
**As a** developer  
**I want** to safely migrate from the device token authentication system to Supabase authentication  
**So that** I can maintain data integrity, ensure zero downtime, and provide a smooth transition for existing admin users  

## Acceptance Criteria

### Migration Planning & Strategy
1. Migration strategy supports zero-downtime deployment
2. Rollback plan is documented and tested
3. Data backup procedures are implemented
4. Migration timeline is clearly defined
5. Risk assessment and mitigation strategies are documented
6. Communication plan for stakeholders is prepared
7. Testing strategy covers all migration scenarios
8. Performance impact assessment is completed
9. Security audit of migration process is conducted
10. Monitoring and alerting for migration process is implemented

### Data Migration & Integrity
11. Existing admin device tokens are identified and catalogued
12. Admin user accounts are created in Supabase Auth
13. Device token data is preserved for audit purposes
14. Data integrity checks validate successful migration
15. Foreign key relationships are properly updated
16. Audit logs track all migration activities
17. Data validation ensures no information loss
18. Backup verification confirms data recoverability
19. Migration scripts handle edge cases gracefully
20. Data consistency checks validate referential integrity

### Dual Authentication Support
21. System supports both device tokens and Supabase auth temporarily
22. Authentication components handle both systems seamlessly
23. User experience remains consistent during transition
24. API endpoints work with both authentication methods
25. Session management supports both systems
26. Error handling covers both authentication types
27. Logging distinguishes between authentication methods
28. Performance impact of dual system is minimized
29. Security is maintained across both systems
30. Configuration allows easy switching between systems

### Legacy System Cleanup
31. Device token system is safely disabled after migration
32. Unused device token code is removed
33. Database tables are cleaned up appropriately
34. Configuration files are updated
35. Documentation reflects new authentication system
36. Dependencies on device token system are removed
37. Test cases are updated for new authentication
38. Monitoring systems are updated
39. Error handling for device tokens is removed
40. Security policies are updated

### Testing & Validation
41. Migration process is tested in staging environment
42. Rollback procedures are validated
43. Performance testing confirms no degradation
44. Security testing validates new authentication
45. User acceptance testing confirms functionality
46. Load testing validates system under stress
47. Integration testing covers all components
48. Regression testing ensures existing features work
49. Accessibility testing validates compliance
50. Cross-browser testing confirms compatibility

## Tasks / Subtasks

- [ ] **Task 1: Migration Planning & Assessment** (AC: 1-10)
  - [ ] Create comprehensive migration strategy document
  - [ ] Develop detailed rollback procedures
  - [ ] Implement automated backup systems
  - [ ] Create migration helpers to support both authentication methods
  - [ ] Conduct risk assessment and mitigation planning
  - [ ] Prepare stakeholder communication materials
  - [ ] Design comprehensive testing strategy
  - [ ] Perform performance impact assessment
  - [ ] Conduct security audit of migration process
  - [ ] Set up monitoring and alerting systems

- [ ] **Task 2: Data Analysis & Preparation** (AC: 11-20)
  - [ ] Analyze existing device token data structure
  - [ ] Create admin user mapping strategy
  - [ ] Design data preservation and audit systems
  - [ ] Implement data integrity validation tools
  - [ ] Create migration scripts with error handling
  - [ ] Set up comprehensive audit logging
  - [ ] Implement data validation frameworks
  - [ ] Create backup verification procedures
  - [ ] Handle edge cases and data anomalies
  - [ ] Implement referential integrity checks

- [ ] **Task 3: Dual Authentication Implementation** (AC: 21-30)
  - [ ] Create hybrid authentication middleware
  - [ ] Update API endpoints for dual auth support
  - [ ] Implement seamless session management
  - [ ] Create unified error handling system
  - [ ] Implement authentication method logging
  - [ ] Optimize performance for dual system
  - [ ] Maintain security across both systems
  - [ ] Create configuration management system
  - [ ] Implement authentication method detection
  - [ ] Create monitoring for both auth systems

- [ ] **Task 4: Migration Execution & Monitoring** (AC: 31-40)
  - [ ] Execute phased migration process
  - [ ] Monitor system performance during migration
  - [ ] Validate data integrity at each step
  - [ ] Handle migration errors and edge cases
  - [ ] Communicate progress to stakeholders
  - [ ] Perform real-time system health checks
  - [ ] Execute rollback procedures if needed
  - [ ] Document migration process and outcomes
  - [ ] Validate successful user transitions
  - [ ] Confirm system stability post-migration

- [ ] **Task 5: Legacy Cleanup & Validation** (AC: 41-50)
  - [ ] Safely disable device token authentication
  - [ ] Remove unused device token code
  - [ ] Clean up database tables and indexes
  - [ ] Update configuration and documentation
  - [ ] Remove device token dependencies
  - [ ] Update test suites for new authentication
  - [ ] Update monitoring and alerting systems
  - [ ] Conduct comprehensive system testing
  - [ ] Perform security validation
  - [ ] Execute final performance testing

## Dev Notes

### Migration Strategy Document
```markdown
# Device Token to Supabase Auth Migration Strategy

## Overview
This document outlines the strategy for migrating from device token authentication to Supabase authentication with zero downtime and minimal risk.

## Migration Phases

### Phase 1: Preparation (Week 1)
- Set up Supabase Auth configuration
- Create admin user accounts
- Implement dual authentication support
- Set up monitoring and logging
- Create comprehensive backups

### Phase 2: Dual System (Week 2)
- Deploy dual authentication system
- Monitor system performance
- Validate both authentication methods
- Conduct user acceptance testing
- Prepare for cutover

### Phase 3: Migration (Week 3)
- Execute user migration process
- Monitor system health
- Validate data integrity
- Handle edge cases
- Confirm successful transitions

### Phase 4: Cleanup (Week 4)
- Disable device token system
- Remove legacy code
- Clean up database
- Update documentation
- Conduct final validation

## Risk Mitigation
- Automated rollback procedures
- Real-time monitoring
- Comprehensive testing
- Staged deployment
- Communication protocols
```

### Migration Scripts
```typescript
// scripts/migration/deviceTokenMigration.ts
import { createClient } from '@supabase/supabase-js'
import { Database } from '../../src/lib/types/database.types'
import { logger } from '../utils/logger'
import { validateEmail } from '../utils/validation'

interface DeviceTokenRecord {
  device_token: string
  device_name: string
  device_info: any
  created_at: string
  last_used_at: string
  is_active: boolean
  expires_at: string
}

interface MigrationResult {
  success: boolean
  userId?: string
  email?: string
  error?: string
  deviceToken: string
}

class DeviceTokenMigration {
  private supabase: ReturnType<typeof createClient<Database>>
  private migrationLog: MigrationResult[] = []
  
  constructor() {
    this.supabase = createClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )
  }

  async analyzeMigrationScope(): Promise<{
    totalTokens: number
    activeTokens: number
    adminTokens: number
    expiredTokens: number
  }> {
    try {
      const { data: tokens, error } = await this.supabase
        .from('device_tokens')
        .select('*')
      
      if (error) throw error
      
      const analysis = {
        totalTokens: tokens.length,
        activeTokens: tokens.filter(t => t.is_active).length,
        adminTokens: tokens.filter(t => 
          t.device_info?.type === 'admin' || 
          t.device_name?.toLowerCase().includes('admin')
        ).length,
        expiredTokens: tokens.filter(t => 
          new Date(t.expires_at) < new Date()
        ).length
      }
      
      logger.info('Migration scope analysis:', analysis)
      return analysis
      
    } catch (error) {
      logger.error('Failed to analyze migration scope:', error)
      throw error
    }
  }

  async createAdminUser(deviceToken: DeviceTokenRecord): Promise<MigrationResult> {
    try {
      // Generate email from device info or use default pattern
      const email = this.generateAdminEmail(deviceToken)
      
      if (!validateEmail(email)) {
        throw new Error(`Invalid email generated: ${email}`)
      }
      
      // Create user in Supabase Auth
      const { data: authData, error: authError } = await this.supabase.auth.admin.createUser({
        email,
        password: this.generateSecurePassword(),
        email_confirm: true,
        user_metadata: {
          device_name: deviceToken.device_name,
          migrated_from_device_token: true,
          migration_date: new Date().toISOString(),
          original_device_info: deviceToken.device_info
        },
        app_metadata: {
          is_admin: true,
          role: 'admin'
        }
      })
      
      if (authError) throw authError
      
      // Create admin profile
      const { error: profileError } = await this.supabase
        .from('admin_profiles')
        .insert({
          id: authData.user.id,
          email: authData.user.email!,
          full_name: this.extractFullName(deviceToken),
          device_name: deviceToken.device_name,
          migrated_from_device_token: true,
          original_device_token: deviceToken.device_token,
          migration_date: new Date().toISOString()
        })
      
      if (profileError) throw profileError
      
      // Create user role
      const { error: roleError } = await this.supabase
        .from('user_roles')
        .insert({
          user_id: authData.user.id,
          role: 'admin'
        })
      
      if (roleError) throw roleError
      
      const result: MigrationResult = {
        success: true,
        userId: authData.user.id,
        email: authData.user.email!,
        deviceToken: deviceToken.device_token
      }
      
      this.migrationLog.push(result)
      logger.info(`Successfully migrated device token ${deviceToken.device_token} to user ${authData.user.id}`)
      
      return result
      
    } catch (error) {
      const result: MigrationResult = {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        deviceToken: deviceToken.device_token
      }
      
      this.migrationLog.push(result)
      logger.error(`Failed to migrate device token ${deviceToken.device_token}:`, error)
      
      return result
    }
  }

  private generateAdminEmail(deviceToken: DeviceTokenRecord): string {
    // Try to extract email from device info
    if (deviceToken.device_info?.email) {
      return deviceToken.device_info.email
    }
    
    // Generate email from device name
    const cleanName = deviceToken.device_name
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '')
      .substring(0, 20)
    
    return `admin.${cleanName}@restaurant-system.local`
  }

  private generateSecurePassword(): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*'
    let password = ''
    
    for (let i = 0; i < 16; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length))
    }
    
    return password
  }

  private extractFullName(deviceToken: DeviceTokenRecord): string {
    if (deviceToken.device_info?.full_name) {
      return deviceToken.device_info.full_name
    }
    
    if (deviceToken.device_info?.name) {
      return deviceToken.device_info.name
    }
    
    // Generate from device name
    return deviceToken.device_name
      .split(/[-_\s]+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ')
  }

  async migrateAllDeviceTokens(): Promise<{
    successful: number
    failed: number
    results: MigrationResult[]
  }> {
    try {
      logger.info('Starting device token migration...')
      
      // Get all active admin device tokens
      const { data: tokens, error } = await this.supabase
        .from('device_tokens')
        .select('*')
        .eq('is_active', true)
        .or('device_info->>type.eq.admin,device_name.ilike.%admin%')
      
      if (error) throw error
      
      logger.info(`Found ${tokens.length} device tokens to migrate`)
      
      const results: MigrationResult[] = []
      
      for (const token of tokens) {
        const result = await this.createAdminUser(token)
        results.push(result)
        
        // Add delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100))
      }
      
      const successful = results.filter(r => r.success).length
      const failed = results.filter(r => !r.success).length
      
      logger.info(`Migration completed: ${successful} successful, ${failed} failed`)
      
      return { successful, failed, results }
      
    } catch (error) {
      logger.error('Migration failed:', error)
      throw error
    }
  }

  async createMigrationAuditLog(): Promise<void> {
    try {
      const auditData = {
        migration_date: new Date().toISOString(),
        total_tokens_processed: this.migrationLog.length,
        successful_migrations: this.migrationLog.filter(r => r.success).length,
        failed_migrations: this.migrationLog.filter(r => !r.success).length,
        migration_results: this.migrationLog
      }
      
      // Store in audit table
      const { error } = await this.supabase
        .from('migration_audit_log')
        .insert(auditData)
      
      if (error) throw error
      
      logger.info('Migration audit log created successfully')
      
    } catch (error) {
      logger.error('Failed to create migration audit log:', error)
      throw error
    }
  }

  async validateMigration(): Promise<{
    isValid: boolean
    issues: string[]
  }> {
    const issues: string[] = []
    
    try {
      // Check if all successful migrations have corresponding users
      const successfulMigrations = this.migrationLog.filter(r => r.success)
      
      for (const migration of successfulMigrations) {
        if (!migration.userId) continue
        
        // Check user exists in auth
        const { data: user, error: userError } = await this.supabase.auth.admin.getUserById(migration.userId)
        if (userError || !user) {
          issues.push(`User ${migration.userId} not found in auth system`)
        }
        
        // Check admin profile exists
        const { data: profile, error: profileError } = await this.supabase
          .from('admin_profiles')
          .select('*')
          .eq('id', migration.userId)
          .single()
        
        if (profileError || !profile) {
          issues.push(`Admin profile for user ${migration.userId} not found`)
        }
        
        // Check user role exists
        const { data: role, error: roleError } = await this.supabase
          .from('user_roles')
          .select('*')
          .eq('user_id', migration.userId)
          .eq('role', 'admin')
          .single()
        
        if (roleError || !role) {
          issues.push(`Admin role for user ${migration.userId} not found`)
        }
      }
      
      return {
        isValid: issues.length === 0,
        issues
      }
      
    } catch (error) {
      issues.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`)
      return { isValid: false, issues }
    }
  }
}

export { DeviceTokenMigration }
```

### Dual Authentication Middleware
```typescript
// src/middleware/dualAuth.ts
import { NextRequest, NextResponse } from 'next/server'
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import type { Database } from '../lib/types/database.types'

interface AuthResult {
  isAuthenticated: boolean
  isAdmin: boolean
  userId?: string
  authMethod: 'supabase' | 'device_token' | 'none'
  error?: string
}

class DualAuthenticationMiddleware {
  private supabase: ReturnType<typeof createMiddlewareClient<Database>>
  
  constructor(request: NextRequest, response: NextResponse) {
    this.supabase = createMiddlewareClient<Database>({ req: request, res: response })
  }

  async authenticateRequest(request: NextRequest): Promise<AuthResult> {
    // Try Supabase authentication first
    const supabaseAuth = await this.authenticateWithSupabase()
    if (supabaseAuth.isAuthenticated) {
      return { ...supabaseAuth, authMethod: 'supabase' }
    }
    
    // Fallback to device token authentication
    const deviceTokenAuth = await this.authenticateWithDeviceToken(request)
    if (deviceTokenAuth.isAuthenticated) {
      return { ...deviceTokenAuth, authMethod: 'device_token' }
    }
    
    return {
      isAuthenticated: false,
      isAdmin: false,
      authMethod: 'none',
      error: 'No valid authentication found'
    }
  }

  private async authenticateWithSupabase(): Promise<Omit<AuthResult, 'authMethod'>> {
    try {
      const { data: { session }, error } = await this.supabase.auth.getSession()
      
      if (error || !session) {
        return { isAuthenticated: false, isAdmin: false }
      }
      
      // Check if session is expired
      if (session.expires_at && session.expires_at * 1000 < Date.now()) {
        return { isAuthenticated: false, isAdmin: false, error: 'Session expired' }
      }
      
      const user = session.user
      const isAdmin = user.app_metadata?.is_admin || user.user_metadata?.is_admin || false
      
      return {
        isAuthenticated: true,
        isAdmin,
        userId: user.id
      }
      
    } catch (error) {
      return {
        isAuthenticated: false,
        isAdmin: false,
        error: error instanceof Error ? error.message : 'Supabase auth error'
      }
    }
  }

  private async authenticateWithDeviceToken(request: NextRequest): Promise<Omit<AuthResult, 'authMethod'>> {
    try {
      const deviceToken = request.headers.get('x-device-token') || 
                         request.cookies.get('device_token')?.value
      
      if (!deviceToken) {
        return { isAuthenticated: false, isAdmin: false }
      }
      
      // Check device token first (legacy)
      const deviceToken = localStorage.getItem('admin_device_token')
      if (deviceToken) {
        const { data: tokenData, error } = await this.supabase
          .from('device_tokens')
          .select('*')
          .eq('device_token', deviceToken)
          .eq('is_active', true)
          .gte('expires_at', new Date().toISOString())
          .single()
        
        if (error || !tokenData) {
          return { isAuthenticated: false, isAdmin: false, error: 'Invalid device token' }
        }
        
        // Check if token is expired
        if (new Date(tokenData.expires_at) < new Date()) {
          return { isAuthenticated: false, isAdmin: false, error: 'Device token expired' }
        }
        
        // Check if it's an admin token
        const isAdmin = tokenData.device_info?.type === 'admin' ||
                       tokenData.device_name?.toLowerCase().includes('admin')
        
        // Update last used timestamp
        await this.supabase
          .from('device_tokens')
          .update({ last_used_at: new Date().toISOString() })
          .eq('device_token', deviceToken)
        
        return {
          isAuthenticated: true,
          isAdmin,
          userId: `device_token_${tokenData.device_token}`
        }
      }
      
      // Validate device token
      const { data: tokenData, error } = await this.supabase
        .from('device_tokens')
        .select('*')
        .eq('device_token', deviceToken)
        .eq('is_active', true)
        .single()
      
      if (error || !tokenData) {
        return { isAuthenticated: false, isAdmin: false, error: 'Invalid device token' }
      }
      
      // Check if token is expired
      if (new Date(tokenData.expires_at) < new Date()) {
        return { isAuthenticated: false, isAdmin: false, error: 'Device token expired' }
      }
      
      // Check if it's an admin token
      const isAdmin = tokenData.device_info?.type === 'admin' ||
                     tokenData.device_name?.toLowerCase().includes('admin')
      
      // Update last used timestamp
      await this.supabase
        .from('device_tokens')
        .update({ last_used_at: new Date().toISOString() })
        .eq('device_token', deviceToken)
      
      return {
        isAuthenticated: true,
        isAdmin,
        userId: `device_token_${tokenData.device_token}`
      }
      
    } catch (error) {
      return {
        isAuthenticated: false,
        isAdmin: false,
        error: error instanceof Error ? error.message : 'Device token auth error'
      }
    }
  }
}

export async function dualAuthMiddleware(request: NextRequest) {
  const response = NextResponse.next()
  const authMiddleware = new DualAuthenticationMiddleware(request, response)
  
  // Skip auth for public routes
  const publicRoutes = ['/api/public', '/api/menu', '/api/rooms', '/api/bookings/create']
  const isPublicRoute = publicRoutes.some(route => request.nextUrl.pathname.startsWith(route))
  
  if (isPublicRoute) {
    return response
  }
  
  // Check if route requires authentication
  const adminRoutes = ['/admin', '/api/admin']
  const isAdminRoute = adminRoutes.some(route => request.nextUrl.pathname.startsWith(route))
  
  if (!isAdminRoute) {
    return response
  }
  
  try {
    const authResult = await authMiddleware.authenticateRequest(request)
    
    if (!authResult.isAuthenticated) {
      const signInUrl = new URL('/admin/auth', request.url)
      signInUrl.searchParams.set('redirectTo', request.nextUrl.pathname + request.nextUrl.search)
      return NextResponse.redirect(signInUrl)
    }
    
    if (!authResult.isAdmin) {
      return new NextResponse('Forbidden', { status: 403 })
    }
    
    // Add auth info to headers
    response.headers.set('X-Auth-Method', authResult.authMethod)
    response.headers.set('X-User-ID', authResult.userId || '')
    response.headers.set('X-Is-Admin', 'true')
    
    return response
    
  } catch (error) {
    console.error('Dual auth middleware error:', error)
    return new NextResponse('Internal Server Error', { status: 500 })
  }
}
```

### Migration Rollback Procedures
```typescript
// src/lib/migration-auth.ts
import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/supabase'
import { supabase } from './supabase'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL!
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY!

class MigrationRollback {
  private supabase: ReturnType<typeof createClient<Database>>
  
  constructor() {
    this.supabase = createClient<Database>(supabaseUrl, supabaseAnonKey)
    this.supabase = createClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )
  }

  async rollbackMigration(migrationId: string): Promise<{
    success: boolean
    rollbackActions: string[]
    errors: string[]
  }> {
    const rollbackActions: string[] = []
    const errors: string[] = []
    
    try {
      logger.info(`Starting rollback for migration ${migrationId}`)
      
      // Get migration audit log
      const { data: auditLog, error: auditError } = await this.supabase
        .from('migration_audit_log')
        .select('*')
        .eq('id', migrationId)
        .single()
      
      if (auditError || !auditLog) {
        throw new Error(`Migration audit log not found: ${migrationId}`)
      }
      
      const migrationResults = auditLog.migration_results as any[]
      const successfulMigrations = migrationResults.filter(r => r.success)
      
      // Rollback each successful migration
      for (const migration of successfulMigrations) {
        try {
          await this.rollbackSingleUser(migration)
          rollbackActions.push(`Rolled back user ${migration.userId}`)
        } catch (error) {
          const errorMsg = `Failed to rollback user ${migration.userId}: ${error}`
          errors.push(errorMsg)
          logger.error(errorMsg)
        }
      }
      
      // Reactivate device tokens
      await this.reactivateDeviceTokens(successfulMigrations)
      rollbackActions.push('Reactivated device tokens')
      
      // Mark migration as rolled back
      await this.supabase
        .from('migration_audit_log')
        .update({ 
          status: 'rolled_back',
          rollback_date: new Date().toISOString(),
          rollback_actions: rollbackActions,
          rollback_errors: errors
        })
        .eq('id', migrationId)
      
      logger.info(`Rollback completed for migration ${migrationId}`)
      
      return {
        success: errors.length === 0,
        rollbackActions,
        errors
      }
      
    } catch (error) {
      const errorMsg = `Rollback failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      errors.push(errorMsg)
      logger.error(errorMsg)
      
      return {
        success: false,
        rollbackActions,
        errors
      }
    }
  }

  private async rollbackSingleUser(migration: any): Promise<void> {
    const { userId, deviceToken } = migration
    
    // Delete user from Supabase Auth
    const { error: authError } = await this.supabase.auth.admin.deleteUser(userId)
    if (authError) {
      logger.warn(`Failed to delete auth user ${userId}: ${authError.message}`)
    }
    
    // Delete admin profile
    const { error: profileError } = await this.supabase
      .from('admin_profiles')
      .delete()
      .eq('id', userId)
    
    if (profileError) {
      logger.warn(`Failed to delete admin profile ${userId}: ${profileError.message}`)
    }
    
    // Delete user role
    const { error: roleError } = await this.supabase
      .from('user_roles')
      .delete()
      .eq('user_id', userId)
    
    if (roleError) {
      logger.warn(`Failed to delete user role ${userId}: ${roleError.message}`)
    }
  }

  private async reactivateDeviceTokens(migrations: any[]): Promise<void> {
    const deviceTokens = migrations.map(m => m.deviceToken).filter(Boolean)
    
    if (deviceTokens.length === 0) return
    
    const { error } = await this.supabase
      .from('device_tokens')
      .update({ is_active: true })
      .in('device_token', deviceTokens)
    
    if (error) {
      throw new Error(`Failed to reactivate device tokens: ${error.message}`)
    }
  }
}

export { MigrationRollback }
```

### Legacy Cleanup Scripts
```typescript
// scripts/cleanup/legacyCleanup.ts
import { createClient } from '@supabase/supabase-js'
import { Database } from '../../src/lib/types/database.types'
import { logger } from '../utils/logger'
import fs from 'fs/promises'
import path from 'path'

class LegacyCleanup {
  private supabase: ReturnType<typeof createClient<Database>>
  
  constructor() {
    this.supabase = createClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )
  }

  async cleanupDeviceTokenSystem(): Promise<{
    success: boolean
    cleanupActions: string[]
    errors: string[]
  }> {
    const cleanupActions: string[] = []
    const errors: string[] = []
    
    try {
      logger.info('Starting legacy device token system cleanup')
      
      // 1. Archive device token data
      await this.archiveDeviceTokens()
      cleanupActions.push('Archived device token data')
      
      // 2. Remove device token code files
      await this.removeDeviceTokenCode()
      cleanupActions.push('Removed device token code files')
      
      // 3. Update configuration files
      await this.updateConfigurationFiles()
      cleanupActions.push('Updated configuration files')
      
      // 4. Clean up database tables
      await this.cleanupDatabaseTables()
      cleanupActions.push('Cleaned up database tables')
      
      // 5. Update documentation
      await this.updateDocumentation()
      cleanupActions.push('Updated documentation')
      
      // 6. Remove test files
      await this.removeTestFiles()
      cleanupActions.push('Removed device token test files')
      
      logger.info('Legacy cleanup completed successfully')
      
      return {
        success: true,
        cleanupActions,
        errors
      }
      
    } catch (error) {
      const errorMsg = `Cleanup failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      errors.push(errorMsg)
      logger.error(errorMsg)
      
      return {
        success: false,
        cleanupActions,
        errors
      }
    }
  }

  private async archiveDeviceTokens(): Promise<void> {
    // Create archive table
    const { error: createError } = await this.supabase.rpc('create_device_tokens_archive')
    if (createError) {
      throw new Error(`Failed to create archive table: ${createError.message}`)
    }
    
    // Copy data to archive
    const { error: copyError } = await this.supabase.rpc('archive_device_tokens')
    if (copyError) {
      throw new Error(`Failed to archive device tokens: ${copyError.message}`)
    }
  }

  private async removeDeviceTokenCode(): Promise<void> {
    const filesToRemove = [
      'src/lib/deviceToken.ts',
      'src/middleware/deviceTokenAuth.ts',
      'src/components/DeviceTokenAuth.tsx',
      'src/hooks/useDeviceToken.ts',
      'src/utils/deviceTokenValidation.ts'
    ]
    
    for (const file of filesToRemove) {
      try {
        await fs.unlink(path.join(process.cwd(), file))
        logger.info(`Removed file: ${file}`)
      } catch (error) {
        // File might not exist, which is fine
        logger.warn(`Could not remove file ${file}: ${error}`)
      }
    }
  }

  private async updateConfigurationFiles(): Promise<void> {
    // Update environment variables template
    const envTemplate = await fs.readFile('.env.example', 'utf-8')
    const updatedEnvTemplate = envTemplate
      .replace(/DEVICE_TOKEN_.*=.*/g, '')
      .replace(/\n\n+/g, '\n\n')
    
    await fs.writeFile('.env.example', updatedEnvTemplate)
    
    // Update package.json scripts if needed
    const packageJson = JSON.parse(await fs.readFile('package.json', 'utf-8'))
    if (packageJson.scripts['device-token:generate']) {
      delete packageJson.scripts['device-token:generate']
      await fs.writeFile('package.json', JSON.stringify(packageJson, null, 2))
    }
  }

  private async cleanupDatabaseTables(): Promise<void> {
    // Drop device_tokens table (after archiving)
    const { error: dropError } = await this.supabase.rpc('drop_device_tokens_table')
    if (dropError) {
      throw new Error(`Failed to drop device_tokens table: ${dropError.message}`)
    }
    
    // Remove device token related indexes
    const { error: indexError } = await this.supabase.rpc('cleanup_device_token_indexes')
    if (indexError) {
      logger.warn(`Failed to cleanup indexes: ${indexError.message}`)
    }
  }

  private async updateDocumentation(): Promise<void> {
    const docsToUpdate = [
      'README.md',
      'docs/AUTHENTICATION.md',
      'docs/API.md',
      'docs/DEPLOYMENT.md'
    ]
    
    for (const docFile of docsToUpdate) {
      try {
        const content = await fs.readFile(docFile, 'utf-8')
        const updatedContent = content
          .replace(/## Device Token Authentication[\s\S]*?(?=##|$)/g, '')
          .replace(/device.?token/gi, '')
          .replace(/\n\n+/g, '\n\n')
        
        await fs.writeFile(docFile, updatedContent)
        logger.info(`Updated documentation: ${docFile}`)
      } catch (error) {
        logger.warn(`Could not update documentation ${docFile}: ${error}`)
      }
    }
  }

  private async removeTestFiles(): Promise<void> {
    const testFilesToRemove = [
      '__tests__/deviceToken.test.ts',
      '__tests__/components/DeviceTokenAuth.test.tsx',
      '__tests__/middleware/deviceTokenAuth.test.ts'
    ]
    
    for (const testFile of testFilesToRemove) {
      try {
        await fs.unlink(path.join(process.cwd(), testFile))
        logger.info(`Removed test file: ${testFile}`)
      } catch (error) {
        logger.warn(`Could not remove test file ${testFile}: ${error}`)
      }
    }
  }
}

export { LegacyCleanup }
```

### Migration Monitoring Dashboard
```typescript
// src/components/admin/MigrationMonitor.tsx
import React, { useState, useEffect } from 'react'
import { useSupabaseAdmin } from '../../hooks/useSupabaseAdmin'

interface MigrationStatus {
  id: string
  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'rolled_back'
  total_tokens_processed: number
  successful_migrations: number
  failed_migrations: number
  migration_date: string
  completion_date?: string
  errors?: string[]
}

export default function MigrationMonitor() {
  const [migrationStatus, setMigrationStatus] = useState<MigrationStatus[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const supabase = useSupabaseAdmin()

  useEffect(() => {
    fetchMigrationStatus()
    
    // Set up real-time updates
    const subscription = supabase
      .channel('migration_status')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'migration_audit_log'
      }, () => {
        fetchMigrationStatus()
      })
      .subscribe()

    return () => {
      subscription.unsubscribe()
    }
  }, [])

  const fetchMigrationStatus = async () => {
    try {
      const { data, error } = await supabase
        .from('migration_audit_log')
        .select('*')
        .order('migration_date', { ascending: false })
      
      if (error) throw error
      
      setMigrationStatus(data || [])
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch migration status')
    } finally {
      setLoading(false)
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'completed': return 'text-green-600 bg-green-100'
      case 'failed': return 'text-red-600 bg-red-100'
      case 'in_progress': return 'text-yellow-600 bg-yellow-100'
      case 'rolled_back': return 'text-gray-600 bg-gray-100'
      default: return 'text-blue-600 bg-blue-100'
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-md p-4">
        <div className="text-red-800">
          <strong>Error:</strong> {error}
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="bg-white shadow rounded-lg">
        <div className="px-4 py-5 sm:p-6">
          <h3 className="text-lg leading-6 font-medium text-gray-900 mb-4">
            Migration Status
          </h3>
          
          {migrationStatus.length === 0 ? (
            <p className="text-gray-500">No migrations found.</p>
          ) : (
            <div className="overflow-hidden shadow ring-1 ring-black ring-opacity-5 md:rounded-lg">
              <table className="min-w-full divide-y divide-gray-300">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Migration ID
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Status
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Progress
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Date
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {migrationStatus.map((migration) => (
                    <tr key={migration.id}>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        {migration.id.substring(0, 8)}...
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${getStatusColor(migration.status)}`}>
                          {migration.status.replace('_', ' ').toUpperCase()}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        <div className="flex items-center">
                          <div className="flex-1">
                            <div className="text-sm">
                              {migration.successful_migrations} / {migration.total_tokens_processed} successful
                            </div>
                            {migration.failed_migrations > 0 && (
                              <div className="text-sm text-red-600">
                                {migration.failed_migrations} failed
                              </div>
                            )}
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {new Date(migration.migration_date).toLocaleDateString()}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                        <button className="text-blue-600 hover:text-blue-900">
                          View Details
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
```

### Testing Infrastructure
```typescript
// __tests__/migration/deviceTokenMigration.test.ts
import { DeviceTokenMigration } from '../../scripts/migration/deviceTokenMigration'
import { createClient } from '@supabase/supabase-js'

// Mock Supabase client
jest.mock('@supabase/supabase-js')

const mockSupabase = {
  from: jest.fn(() => ({
    select: jest.fn().mockReturnThis(),
    insert: jest.fn().mockReturnThis(),
    update: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    single: jest.fn()
  })),
  auth: {
    admin: {
      createUser: jest.fn(),
      getUserById: jest.fn(),
      deleteUser: jest.fn()
    }
  }
}

;(createClient as jest.Mock).mockReturnValue(mockSupabase)

describe('DeviceTokenMigration', () => {
  let migration: DeviceTokenMigration

  beforeEach(() => {
    jest.clearAllMocks()
    migration = new DeviceTokenMigration()
  })

  describe('analyzeMigrationScope', () => {
    test('should analyze device tokens correctly', async () => {
      const mockTokens = [
        { device_token: 'token1', is_active: true, device_info: { type: 'admin' }, expires_at: '2025-01-01' },
        { device_token: 'token2', is_active: false, device_info: { type: 'user' }, expires_at: '2024-01-01' },
        { device_token: 'token3', is_active: true, device_name: 'admin-device', expires_at: '2025-01-01' }
      ]

      mockSupabase.from().select().mockResolvedValue({ data: mockTokens, error: null })

      const result = await migration.analyzeMigrationScope()

      expect(result).toEqual({
        totalTokens: 3,
        activeTokens: 2,
        adminTokens: 2,
        expiredTokens: 1
      })
    })

    test('should handle database errors', async () => {
      mockSupabase.from().select().mockResolvedValue({ data: null, error: new Error('DB Error') })

      await expect(migration.analyzeMigrationScope()).rejects.toThrow('DB Error')
    })
  })

  describe('createAdminUser', () => {
    const mockDeviceToken = {
      device_token: 'test-token',
      device_name: 'Admin Device',
      device_info: { type: 'admin', email: 'admin@test.com' },
      created_at: '2024-01-01',
      last_used_at: '2024-01-01',
      is_active: true,
      expires_at: '2025-01-01'
    }

    test('should create admin user successfully', async () => {
      const mockUser = { id: 'user-123', email: 'admin@test.com' }
      
      mockSupabase.auth.admin.createUser.mockResolvedValue({ data: { user: mockUser }, error: null })
      mockSupabase.from().insert().mockResolvedValue({ error: null })

      const result = await migration.createAdminUser(mockDeviceToken)

      expect(result.success).toBe(true)
      expect(result.userId).toBe('user-123')
      expect(result.email).toBe('admin@test.com')
      expect(mockSupabase.auth.admin.createUser).toHaveBeenCalledWith({
        email: 'admin@test.com',
        password: expect.any(String),
        email_confirm: true,
        user_metadata: expect.objectContaining({
          device_name: 'Admin Device',
          migrated_from_device_token: true
        }),
        app_metadata: {
          is_admin: true,
          role: 'admin'
        }
      })
    })

    test('should handle auth creation errors', async () => {
      mockSupabase.auth.admin.createUser.mockResolvedValue({ 
        data: null, 
        error: new Error('Auth error') 
      })

      const result = await migration.createAdminUser(mockDeviceToken)

      expect(result.success).toBe(false)
      expect(result.error).toBe('Auth error')
    })
  })
})
```

### Performance Testing
```typescript
// __tests__/performance/migrationPerformance.test.ts
import { DeviceTokenMigration } from '../../scripts/migration/deviceTokenMigration'

describe('Migration Performance Tests', () => {
  let migration: DeviceTokenMigration

  beforeEach(() => {
    migration = new DeviceTokenMigration()
  })

  test('should handle large number of device tokens efficiently', async () => {
    const startTime = Date.now()
    
    // Mock large dataset
    const largeTokenSet = Array.from({ length: 1000 }, (_, i) => ({
      device_token: `token-${i}`,
      device_name: `Device ${i}`,
      device_info: { type: 'admin' },
      created_at: '2024-01-01',
      last_used_at: '2024-01-01',
      is_active: true,
      expires_at: '2025-01-01'
    }))

    // Test migration performance
    // Implementation would depend on actual migration logic
    
    const endTime = Date.now()
    const duration = endTime - startTime
    
    // Should complete within reasonable time (adjust threshold as needed)
    expect(duration).toBeLessThan(30000) // 30 seconds
  }, 60000) // 60 second timeout

  test('should maintain consistent performance under load', async () => {
    const iterations = 10
    const durations: number[] = []

    for (let i = 0; i < iterations; i++) {
      const startTime = Date.now()
      
      // Simulate migration operation
      await new Promise(resolve => setTimeout(resolve, 100))
      
      const duration = Date.now() - startTime
      durations.push(duration)
    }

    // Calculate performance metrics
    const avgDuration = durations.reduce((sum, d) => sum + d, 0) / durations.length
    const maxDuration = Math.max(...durations)
    const minDuration = Math.min(...durations)
    
    // Performance should be consistent (low variance)
    const variance = maxDuration - minDuration
    expect(variance).toBeLessThan(avgDuration * 0.5) // Variance should be less than 50% of average
  })
})
```

### Testing Checklist
- [ ] Migration scope analysis works correctly
- [ ] Admin user creation handles all scenarios
- [ ] Data integrity validation catches issues
- [ ] Dual authentication middleware works seamlessly
- [ ] Rollback procedures restore system state
- [ ] Legacy cleanup removes all device token code
- [ ] Migration monitoring provides real-time updates
- [ ] Performance testing validates efficiency
- [ ] Security testing confirms no vulnerabilities
- [ ] Error handling covers all edge cases
- [ ] Audit logging captures all activities
- [ ] Backup and restore procedures work correctly
- [ ] Configuration updates are applied correctly
- [ ] Documentation reflects new authentication system
- [ ] Integration testing validates end-to-end flow
- [ ] Load testing confirms system stability
- [ ] Accessibility testing validates compliance
- [ ] Cross-browser testing confirms compatibility
- [ ] Mobile testing validates responsive design
- [ ] TypeScript types are correct and complete

### Documentation Requirements
- Create comprehensive migration guide with step-by-step instructions
- Document rollback procedures and emergency protocols
- Create troubleshooting guide for common migration issues
- Document performance optimization techniques
- Create security best practices documentation
- Document monitoring and alerting setup
- Create user communication templates
- Document testing procedures and validation steps
- Create post-migration cleanup checklist
- Document lessons learned and recommendations for future migrations