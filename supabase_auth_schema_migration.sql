-- Supabase Auth Schema & Security Setup
-- Story 5.1 implementation: roles, profiles, hooks, RLS, grants

-- 1) Custom types for role management
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_role') THEN
    CREATE TYPE public.app_role AS ENUM ('admin');
  END IF;
END$$;

-- 2) User roles table
CREATE TABLE IF NOT EXISTS public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role public.app_role NOT NULL DEFAULT 'admin',
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  assigned_by UUID REFERENCES auth.users,
  is_active BOOLEAN DEFAULT true,
  UNIQUE (user_id, role)
);

-- 3) Admin profiles table
CREATE TABLE IF NOT EXISTS public.admin_profiles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL UNIQUE,
  full_name TEXT,
  phone TEXT,
  department TEXT,
  position TEXT,
  permissions JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4) Indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_roles_user_id ON public.user_roles(user_id);
CREATE INDEX IF NOT EXISTS idx_user_roles_role ON public.user_roles(role);
CREATE INDEX IF NOT EXISTS idx_admin_profiles_user_id ON public.admin_profiles(user_id);

-- 5) Updated-at trigger function and trigger
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS admin_profiles_updated_at ON public.admin_profiles;
CREATE TRIGGER admin_profiles_updated_at
  BEFORE UPDATE ON public.admin_profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- 6) Enable Row Level Security
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_profiles ENABLE ROW LEVEL SECURITY;

-- 7) Policies
-- 7.1 Auth admin can read user_roles (required for access token hook)
DROP POLICY IF EXISTS "Allow auth admin to read user roles" ON public.user_roles;
CREATE POLICY "Allow auth admin to read user roles"
  ON public.user_roles
  AS PERMISSIVE FOR SELECT
  TO supabase_auth_admin
  USING (true);

-- 7.2 Admin users can view and update their own profile
DROP POLICY IF EXISTS "Admin users can view and update their own profile" ON public.admin_profiles;
CREATE POLICY "Admin users can view and update their own profile"
  ON public.admin_profiles
  FOR ALL
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- 8) Helper to read admin flag from JWT claims inserted by hook
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  RETURN COALESCE(
    (SELECT (auth.jwt()->>'is_admin')::boolean),
    false
  );
END;
$$;

-- 9) Automatic admin profile creation when admin role is assigned
CREATE OR REPLACE FUNCTION public.handle_new_admin_user()
RETURNS TRIGGER AS $$
BEGIN
  -- Only create profile if user has admin role
  IF EXISTS (
    SELECT 1 FROM public.user_roles 
    WHERE user_id = NEW.user_id AND role = 'admin'
  ) THEN
    INSERT INTO public.admin_profiles (user_id, full_name)
    VALUES (
      NEW.user_id,
      COALESCE((SELECT raw_user_meta_data->>'full_name' FROM auth.users WHERE id = NEW.user_id), 'Admin User')
    )
    ON CONFLICT (user_id) DO NOTHING;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_admin_role_created ON public.user_roles;
CREATE TRIGGER on_admin_role_created
  AFTER INSERT ON public.user_roles
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_admin_user();

-- 10) Role management functions
CREATE OR REPLACE FUNCTION public.assign_admin_role(
  target_user_id uuid,
  assigned_by_user_id uuid DEFAULT auth.uid()
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Check if caller is admin
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admin users can assign roles';
  END IF;

  -- Insert or update user role
  INSERT INTO public.user_roles (user_id, role, assigned_by)
  VALUES (target_user_id, 'admin', assigned_by_user_id)
  ON CONFLICT (user_id, role) 
  DO UPDATE SET 
    is_active = true,
    assigned_at = NOW(),
    assigned_by = assigned_by_user_id;

  RETURN true;
EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Error assigning admin role: %', SQLERRM;
    RETURN false;
END;
$$;

CREATE OR REPLACE FUNCTION public.revoke_admin_role(
  target_user_id uuid
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Check if caller is admin
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admin users can revoke roles';
  END IF;

  -- Deactivate user role
  UPDATE public.user_roles 
  SET is_active = false
  WHERE user_id = target_user_id AND role = 'admin';

  RETURN true;
EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Error revoking admin role: %', SQLERRM;
    RETURN false;
END;
$$;

-- 11) Custom access token hook function: inject user_role and is_admin
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims jsonb;
  user_role public.app_role;
  is_admin boolean := false;
BEGIN
  -- Fetch the user role from user_roles table
  SELECT role INTO user_role 
  FROM public.user_roles 
  WHERE user_id = (event->>'user_id')::uuid 
    AND is_active = true
  ORDER BY assigned_at DESC
  LIMIT 1;

  -- Get existing claims
  claims := event->'claims';

  -- Set user role claim
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    is_admin := true;
  ELSE
    claims := jsonb_set(claims, '{user_role}', 'null'::jsonb);
  END IF;

  -- Set admin status claim
  claims := jsonb_set(claims, '{is_admin}', to_jsonb(is_admin));

  -- Update the claims in the event
  event := jsonb_set(event, '{claims}', claims);

  RETURN event;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error and return original event
    RAISE LOG 'Error in custom_access_token_hook: %', SQLERRM;
    RETURN event;
END;
$$;

-- 12) Grants and permissions for hook and tables
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) FROM authenticated, anon, public;

GRANT SELECT ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;

-- End of migration
